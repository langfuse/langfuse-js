/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  "/api/public/dataset-items": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Get dataset items */
    get: operations["datasetItems_list"];
    put?: never;
    /** @description Create a dataset item */
    post: operations["datasetItems_create"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/public/dataset-items/{id}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Get a dataset item */
    get: operations["datasetItems_get"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/public/dataset-run-items": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** @description Create a dataset run item */
    post: operations["datasetRunItems_create"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/public/v2/datasets": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Get all datasets */
    get: operations["datasets_list"];
    put?: never;
    /** @description Create a dataset */
    post: operations["datasets_create"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/public/v2/datasets/{datasetName}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Get a dataset and its items */
    get: operations["datasets_get"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/public/datasets/{datasetName}/runs/{runName}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Get a dataset run and its items */
    get: operations["datasets_getRun"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/public/datasets/{datasetName}/runs": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Get a dataset runs */
    get: operations["datasets_getRuns"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/public/health": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Check health of API and database */
    get: operations["health_health"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/public/ingestion": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** @description Batched ingestion for Langfuse Tracing. If you want to use tracing via the API, such as to build your own Langfuse client implementation, this is the only API route you need to implement.
     *
     *     Notes:
     *
     *     - Batch sizes are limited to 3.5 MB in total. You need to adjust the number of events per batch accordingly.
     *     - The API does not return a 4xx status code for input errors. Instead, it responds with a 207 status code, which includes a list of the encountered errors. */
    post: operations["ingestion_batch"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/public/metrics/daily": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Get daily metrics of the Langfuse project */
    get: operations["metrics_daily"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/public/observations/{observationId}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Get a observation */
    get: operations["observations_get"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/public/observations": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Get a list of observations */
    get: operations["observations_getMany"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/public/projects": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Get Project associated with API key */
    get: operations["projects_get"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/public/v2/prompts/{promptName}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Get a prompt */
    get: operations["prompts_get"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/public/v2/prompts": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Get a list of prompt names with versions and labels */
    get: operations["prompts_list"];
    put?: never;
    /** @description Create a prompt */
    post: operations["prompts_create"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/public/score-configs": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Get all score configs */
    get: operations["scoreConfigs_get"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/public/score-configs/{configId}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Get a score config */
    get: operations["scoreConfigs_get-by-id"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/public/scores": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Get a list of scores */
    get: operations["score_get"];
    put?: never;
    /** @description Create a score */
    post: operations["score_create"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/public/scores/{scoreId}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Get a score */
    get: operations["score_get-by-id"];
    put?: never;
    post?: never;
    /** @description Delete a score */
    delete: operations["score_delete"];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/public/sessions/{sessionId}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Get a session. Please note that `traces` on this endpoint are not paginated, if you plan to fetch large sessions, consider `GET /api/public/traces?sessionId=<sessionId>` */
    get: operations["sessions_get"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/public/traces/{traceId}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Get a specific trace */
    get: operations["trace_get"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/public/traces": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Get list of traces. */
    get: operations["trace_list"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
}
export type webhooks = Record<string, never>;
export interface components {
  schemas: {
    /** Trace */
    Trace: {
      /** @description The unique identifier of a trace */
      id: string;
      /** Format: date-time */
      timestamp: string;
      name?: string | null;
      input?: unknown;
      output?: unknown;
      sessionId?: string | null;
      release?: string | null;
      version?: string | null;
      userId?: string | null;
      metadata?: unknown;
      tags?: string[] | null;
      /** @description Public traces are accessible via url without login */
      public?: boolean | null;
    };
    /** TraceWithDetails */
    TraceWithDetails: {
      /** @description Path of trace in Langfuse UI */
      htmlPath: string;
      /**
       * Format: double
       * @description Latency of trace in seconds
       */
      latency: number;
      /**
       * Format: double
       * @description Cost of trace in USD
       */
      totalCost: number;
      /** @description List of observation ids */
      observations: string[];
      /** @description List of score ids */
      scores: string[];
    } & components["schemas"]["Trace"];
    /** TraceWithFullDetails */
    TraceWithFullDetails: {
      /** @description Path of trace in Langfuse UI */
      htmlPath: string;
      /**
       * Format: double
       * @description Cost of trace in USD
       */
      totalCost: number;
      observations: components["schemas"]["ObservationsView"][];
      scores: components["schemas"]["Score"][];
    } & components["schemas"]["Trace"];
    /** Session */
    Session: {
      id: string;
      /** Format: date-time */
      createdAt: string;
      projectId: string;
    };
    /** SessionWithTraces */
    SessionWithTraces: {
      traces: components["schemas"]["Trace"][];
    } & components["schemas"]["Session"];
    /** Observation */
    Observation: {
      id: string;
      traceId?: string | null;
      type: string;
      name?: string | null;
      /** Format: date-time */
      startTime: string;
      /** Format: date-time */
      endTime?: string | null;
      /** Format: date-time */
      completionStartTime?: string | null;
      model?: string | null;
      modelParameters?: {
        [key: string]: components["schemas"]["MapValue"] | undefined;
      } | null;
      input?: unknown;
      version?: string | null;
      metadata?: unknown;
      output?: unknown;
      usage?: components["schemas"]["Usage"];
      level: components["schemas"]["ObservationLevel"];
      statusMessage?: string | null;
      parentObservationId?: string | null;
      promptId?: string | null;
    };
    /** ObservationsView */
    ObservationsView: {
      modelId?: string | null;
      /** Format: double */
      inputPrice?: number | null;
      /** Format: double */
      outputPrice?: number | null;
      /** Format: double */
      totalPrice?: number | null;
      /** Format: double */
      calculatedInputCost?: number | null;
      /** Format: double */
      calculatedOutputCost?: number | null;
      /** Format: double */
      calculatedTotalCost?: number | null;
      /** Format: double */
      latency?: number | null;
    } & components["schemas"]["Observation"];
    /**
     * Usage
     * @description Standard interface for usage and cost
     */
    Usage: {
      /** @description Number of input units (e.g. tokens) */
      input?: number | null;
      /** @description Number of output units (e.g. tokens) */
      output?: number | null;
      /** @description Defaults to input+output if not set */
      total?: number | null;
      unit?: components["schemas"]["ModelUsageUnit"];
      /**
       * Format: double
       * @description USD input cost
       */
      inputCost?: number | null;
      /**
       * Format: double
       * @description USD output cost
       */
      outputCost?: number | null;
      /**
       * Format: double
       * @description USD total cost, defaults to input+output
       */
      totalCost?: number | null;
    };
    /**
     * ScoreConfig
     * @description Configuration for a score
     */
    ScoreConfig: {
      id: string;
      name: string;
      /** Format: date-time */
      createdAt: string;
      /** Format: date-time */
      updatedAt: string;
      projectId: string;
      dataType: components["schemas"]["ScoreDataType"];
      isArchived: boolean;
      /** Format: double */
      minValue?: number | null;
      /** Format: double */
      maxValue?: number | null;
      categories?: components["schemas"]["ConfigCategory"][] | null;
      description?: string | null;
    };
    /** ConfigCategory */
    ConfigCategory: {
      /** Format: double */
      value: number;
      label: string;
    };
    /** Score */
    Score: {
      id: string;
      traceId: string;
      name: string;
      /** Format: double */
      value: number;
      source: components["schemas"]["ScoreSource"];
      observationId?: string | null;
      /** Format: date-time */
      timestamp: string;
      comment?: string | null;
    };
    /** Dataset */
    Dataset: {
      id: string;
      name: string;
      description?: string | null;
      metadata?: unknown;
      projectId: string;
      /** Format: date-time */
      createdAt: string;
      /** Format: date-time */
      updatedAt: string;
    };
    /** DatasetItem */
    DatasetItem: {
      id: string;
      status: components["schemas"]["DatasetStatus"];
      input?: unknown;
      expectedOutput?: unknown;
      metadata?: unknown;
      sourceTraceId?: string | null;
      sourceObservationId?: string | null;
      datasetId: string;
      datasetName: string;
      /** Format: date-time */
      createdAt: string;
      /** Format: date-time */
      updatedAt: string;
    };
    /** DatasetRunItem */
    DatasetRunItem: {
      id: string;
      datasetRunId: string;
      datasetRunName: string;
      datasetItemId: string;
      traceId: string;
      observationId?: string | null;
      /** Format: date-time */
      createdAt: string;
      /** Format: date-time */
      updatedAt: string;
    };
    /** DatasetRun */
    DatasetRun: {
      id: string;
      name: string;
      description?: string | null;
      metadata?: unknown;
      datasetId: string;
      datasetName: string;
      /** Format: date-time */
      createdAt: string;
      /** Format: date-time */
      updatedAt: string;
    };
    /** DatasetRunWithItems */
    DatasetRunWithItems: {
      datasetRunItems: components["schemas"]["DatasetRunItem"][];
    } & components["schemas"]["DatasetRun"];
    /**
     * ModelUsageUnit
     * @description Unit of usage in Langfuse
     * @enum {string}
     */
    ModelUsageUnit: "CHARACTERS" | "TOKENS" | "MILLISECONDS" | "SECONDS" | "IMAGES";
    /**
     * ObservationLevel
     * @enum {string}
     */
    ObservationLevel: "DEBUG" | "DEFAULT" | "WARNING" | "ERROR";
    /** MapValue */
    MapValue: (string | null) | (number | null) | (boolean | null) | (string[] | null);
    /**
     * DatasetStatus
     * @enum {string}
     */
    DatasetStatus: "ACTIVE" | "ARCHIVED";
    /**
     * ScoreSource
     * @enum {string}
     */
    ScoreSource: "ANNOTATION" | "API" | "EVAL";
    /**
     * ScoreDataType
     * @enum {string}
     */
    ScoreDataType: "NUMERIC" | "BOOLEAN" | "CATEGORICAL";
    /** CreateDatasetItemRequest */
    CreateDatasetItemRequest: {
      datasetName: string;
      input?: unknown;
      expectedOutput?: unknown;
      metadata?: unknown;
      sourceTraceId?: string | null;
      sourceObservationId?: string | null;
      /** @description Dataset items are upserted on their id. Id needs to be globally unique and cannot be reused across datasets. */
      id?: string | null;
      /** @description Defaults to ACTIVE for newly created items */
      status?: components["schemas"]["DatasetStatus"];
    };
    /** PaginatedDatasetItems */
    PaginatedDatasetItems: {
      data: components["schemas"]["DatasetItem"][];
      meta: components["schemas"]["utilsMetaResponse"];
    };
    /** CreateDatasetRunItemRequest */
    CreateDatasetRunItemRequest: {
      runName: string;
      /** @description Description of the run. If run exists, description will be updated. */
      runDescription?: string | null;
      /** @description Metadata of the dataset run, updates run if run already exists */
      metadata?: unknown;
      datasetItemId: string;
      observationId?: string | null;
      /** @description traceId should always be provided. For compatibility with older SDK versions it can also be inferred from the provided observationId. */
      traceId?: string | null;
    };
    /** PaginatedDatasets */
    PaginatedDatasets: {
      data: components["schemas"]["Dataset"][];
      meta: components["schemas"]["utilsMetaResponse"];
    };
    /** CreateDatasetRequest */
    CreateDatasetRequest: {
      name: string;
      description?: string | null;
      metadata?: unknown;
    };
    /** PaginatedDatasetRuns */
    PaginatedDatasetRuns: {
      data: components["schemas"]["DatasetRun"][];
      meta: components["schemas"]["utilsMetaResponse"];
    };
    /** HealthResponse */
    HealthResponse: {
      /**
       * @description Langfuse server version
       * @example 1.25.0
       */
      version: string;
      /** @example OK */
      status: string;
    };
    /** IngestionEvent */
    IngestionEvent:
      | ({
          /** @enum {string} */
          type: "trace-create";
        } & components["schemas"]["TraceEvent"])
      | ({
          /** @enum {string} */
          type: "score-create";
        } & components["schemas"]["ScoreEvent"])
      | ({
          /** @enum {string} */
          type: "span-create";
        } & components["schemas"]["CreateSpanEvent"])
      | ({
          /** @enum {string} */
          type: "span-update";
        } & components["schemas"]["UpdateSpanEvent"])
      | ({
          /** @enum {string} */
          type: "generation-create";
        } & components["schemas"]["CreateGenerationEvent"])
      | ({
          /** @enum {string} */
          type: "generation-update";
        } & components["schemas"]["UpdateGenerationEvent"])
      | ({
          /** @enum {string} */
          type: "event-create";
        } & components["schemas"]["CreateEventEvent"])
      | ({
          /** @enum {string} */
          type: "sdk-log";
        } & components["schemas"]["SDKLogEvent"])
      | ({
          /** @enum {string} */
          type: "observation-create";
        } & components["schemas"]["CreateObservationEvent"])
      | ({
          /** @enum {string} */
          type: "observation-update";
        } & components["schemas"]["UpdateObservationEvent"]);
    /**
     * ObservationType
     * @enum {string}
     */
    ObservationType: "SPAN" | "GENERATION" | "EVENT";
    /** IngestionUsage */
    IngestionUsage: components["schemas"]["Usage"] | components["schemas"]["OpenAIUsage"];
    /**
     * OpenAIUsage
     * @description Usage interface of OpenAI for improved compatibility.
     */
    OpenAIUsage: {
      promptTokens?: number | null;
      completionTokens?: number | null;
      totalTokens?: number | null;
    };
    /** OptionalObservationBody */
    OptionalObservationBody: {
      traceId?: string | null;
      name?: string | null;
      /** Format: date-time */
      startTime?: string | null;
      metadata?: unknown;
      input?: unknown;
      output?: unknown;
      level?: components["schemas"]["ObservationLevel"];
      statusMessage?: string | null;
      parentObservationId?: string | null;
      version?: string | null;
    };
    /** CreateEventBody */
    CreateEventBody: {
      id?: string | null;
    } & components["schemas"]["OptionalObservationBody"];
    /** UpdateEventBody */
    UpdateEventBody: {
      id: string;
    } & components["schemas"]["OptionalObservationBody"];
    /** CreateSpanBody */
    CreateSpanBody: {
      /** Format: date-time */
      endTime?: string | null;
    } & components["schemas"]["CreateEventBody"];
    /** UpdateSpanBody */
    UpdateSpanBody: {
      /** Format: date-time */
      endTime?: string | null;
    } & components["schemas"]["UpdateEventBody"];
    /** CreateGenerationBody */
    CreateGenerationBody: {
      /** Format: date-time */
      completionStartTime?: string | null;
      model?: string | null;
      modelParameters?: {
        [key: string]: components["schemas"]["MapValue"] | undefined;
      } | null;
      usage?: components["schemas"]["IngestionUsage"];
      promptName?: string | null;
      promptVersion?: number | null;
    } & components["schemas"]["CreateSpanBody"];
    /** UpdateGenerationBody */
    UpdateGenerationBody: {
      /** Format: date-time */
      completionStartTime?: string | null;
      model?: string | null;
      modelParameters?: {
        [key: string]: components["schemas"]["MapValue"] | undefined;
      } | null;
      usage?: components["schemas"]["IngestionUsage"];
      promptName?: string | null;
      promptVersion?: number | null;
    } & components["schemas"]["UpdateSpanBody"];
    /** ObservationBody */
    ObservationBody: {
      id?: string | null;
      traceId?: string | null;
      type: components["schemas"]["ObservationType"];
      name?: string | null;
      /** Format: date-time */
      startTime?: string | null;
      /** Format: date-time */
      endTime?: string | null;
      /** Format: date-time */
      completionStartTime?: string | null;
      model?: string | null;
      modelParameters?: {
        [key: string]: components["schemas"]["MapValue"] | undefined;
      } | null;
      input?: unknown;
      version?: string | null;
      metadata?: unknown;
      output?: unknown;
      usage?: components["schemas"]["Usage"];
      level?: components["schemas"]["ObservationLevel"];
      statusMessage?: string | null;
      parentObservationId?: string | null;
    };
    /** TraceBody */
    TraceBody: {
      id?: string | null;
      /** Format: date-time */
      timestamp?: string | null;
      name?: string | null;
      userId?: string | null;
      input?: unknown;
      output?: unknown;
      sessionId?: string | null;
      release?: string | null;
      version?: string | null;
      metadata?: unknown;
      tags?: string[] | null;
      /** @description Make trace publicly accessible via url */
      public?: boolean | null;
    };
    /** SDKLogBody */
    SDKLogBody: {
      log: unknown;
    };
    /** ScoreBody */
    ScoreBody: {
      id?: string | null;
      traceId: string;
      name: string;
      /** Format: double */
      value: number;
      observationId?: string | null;
      comment?: string | null;
    };
    /** BaseEvent */
    BaseEvent: {
      /** @description UUID v4 that identifies the event */
      id: string;
      /** @description Datetime (ISO 8601) of event creation in client. Should be as close to actual event creation in client as possible, this timestamp will be used for ordering of events in future release. Resolution: milliseconds (required), microseconds (optimal). */
      timestamp: string;
      /** @description Optional. Metadata field used by the Langfuse SDKs for debugging. */
      metadata?: unknown;
    };
    /** TraceEvent */
    TraceEvent: {
      body: components["schemas"]["TraceBody"];
    } & components["schemas"]["BaseEvent"];
    /** CreateObservationEvent */
    CreateObservationEvent: {
      body: components["schemas"]["ObservationBody"];
    } & components["schemas"]["BaseEvent"];
    /** UpdateObservationEvent */
    UpdateObservationEvent: {
      body: components["schemas"]["ObservationBody"];
    } & components["schemas"]["BaseEvent"];
    /** ScoreEvent */
    ScoreEvent: {
      body: components["schemas"]["ScoreBody"];
    } & components["schemas"]["BaseEvent"];
    /** SDKLogEvent */
    SDKLogEvent: {
      body: components["schemas"]["SDKLogBody"];
    } & components["schemas"]["BaseEvent"];
    /** CreateGenerationEvent */
    CreateGenerationEvent: {
      body: components["schemas"]["CreateGenerationBody"];
    } & components["schemas"]["BaseEvent"];
    /** UpdateGenerationEvent */
    UpdateGenerationEvent: {
      body: components["schemas"]["UpdateGenerationBody"];
    } & components["schemas"]["BaseEvent"];
    /** CreateSpanEvent */
    CreateSpanEvent: {
      body: components["schemas"]["CreateSpanBody"];
    } & components["schemas"]["BaseEvent"];
    /** UpdateSpanEvent */
    UpdateSpanEvent: {
      body: components["schemas"]["UpdateSpanBody"];
    } & components["schemas"]["BaseEvent"];
    /** CreateEventEvent */
    CreateEventEvent: {
      body: components["schemas"]["CreateEventBody"];
    } & components["schemas"]["BaseEvent"];
    /** IngestionSuccess */
    IngestionSuccess: {
      id: string;
      status: number;
    };
    /** IngestionError */
    IngestionError: {
      id: string;
      status: number;
      message?: string | null;
      error?: unknown;
    };
    /** IngestionResponse */
    IngestionResponse: {
      successes: components["schemas"]["IngestionSuccess"][];
      errors: components["schemas"]["IngestionError"][];
    };
    /** DailyMetrics */
    DailyMetrics: {
      /** @description A list of daily metrics, only days with ingested data are included. */
      data: components["schemas"]["DailyMetricsDetails"][];
      meta: components["schemas"]["utilsMetaResponse"];
    };
    /** DailyMetricsDetails */
    DailyMetricsDetails: {
      date: string;
      countTraces: number;
      countObservations: number;
      /**
       * Format: double
       * @description Total model cost in USD
       */
      totalCost: number;
      usage: components["schemas"]["UsageByModel"][];
    };
    /**
     * UsageByModel
     * @description Daily usage of a given model. Usage corresponds to the unit set for the specific model (e.g. tokens).
     */
    UsageByModel: {
      model?: string | null;
      /** @description Total number of generation input units (e.g. tokens) */
      inputUsage: number;
      /** @description Total number of generation output units (e.g. tokens) */
      outputUsage: number;
      /** @description Total number of generation total units (e.g. tokens) */
      totalUsage: number;
      countTraces: number;
      countObservations: number;
      /**
       * Format: double
       * @description Total model cost in USD
       */
      totalCost: number;
    };
    /** Observations */
    Observations: {
      data: components["schemas"]["Observation"][];
      meta: components["schemas"]["utilsMetaResponse"];
    };
    /** ObservationsViews */
    ObservationsViews: {
      data: components["schemas"]["ObservationsView"][];
      meta: components["schemas"]["utilsMetaResponse"];
    };
    /** Projects */
    Projects: {
      data: components["schemas"]["Project"][];
    };
    /** Project */
    Project: {
      id: string;
      name: string;
    };
    /** PromptMetaListResponse */
    PromptMetaListResponse: {
      data: components["schemas"]["PromptMeta"][];
      meta: components["schemas"]["utilsMetaResponse"];
    };
    /** PromptMeta */
    PromptMeta: {
      name: string;
      versions: number[];
      labels: string[];
      tags: string[];
    };
    /** CreatePromptRequest */
    CreatePromptRequest:
      | ({
          /** @enum {string} */
          type: "chat";
        } & components["schemas"]["CreateChatPromptRequest"])
      | ({
          /** @enum {string} */
          type: "text";
        } & components["schemas"]["CreateTextPromptRequest"]);
    /** CreateChatPromptRequest */
    CreateChatPromptRequest: {
      name: string;
      prompt: components["schemas"]["ChatMessage"][];
      config?: unknown;
      /** @description List of deployment labels of this prompt version. */
      labels?: string[] | null;
      /** @description List of tags to apply to all versions of this prompt. */
      tags?: string[] | null;
    };
    /** CreateTextPromptRequest */
    CreateTextPromptRequest: {
      name: string;
      prompt: string;
      config?: unknown;
      /** @description List of deployment labels of this prompt version. */
      labels?: string[] | null;
      /** @description List of tags to apply to all versions of this prompt. */
      tags?: string[] | null;
    };
    /** Prompt */
    Prompt:
      | ({
          /** @enum {string} */
          type: "chat";
        } & components["schemas"]["ChatPrompt"])
      | ({
          /** @enum {string} */
          type: "text";
        } & components["schemas"]["TextPrompt"]);
    /** BasePrompt */
    BasePrompt: {
      name: string;
      version: number;
      config: unknown;
      /** @description List of deployment labels of this prompt version. */
      labels: string[];
      /** @description List of tags. Used to filter via UI and API. The same across versions of a prompt. */
      tags: string[];
    };
    /** ChatMessage */
    ChatMessage: {
      role: string;
      content: string;
    };
    /** TextPrompt */
    TextPrompt: {
      prompt: string;
    } & components["schemas"]["BasePrompt"];
    /** ChatPrompt */
    ChatPrompt: {
      prompt: components["schemas"]["ChatMessage"][];
    } & components["schemas"]["BasePrompt"];
    /** ScoreConfigs */
    ScoreConfigs: {
      data: components["schemas"]["ScoreConfig"][];
      meta: components["schemas"]["utilsMetaResponse"];
    };
    /** CreateScoreRequest */
    CreateScoreRequest: {
      id?: string | null;
      traceId: string;
      name: string;
      /** Format: double */
      value: number;
      observationId?: string | null;
      comment?: string | null;
    };
    /** Scores */
    Scores: {
      data: components["schemas"]["Score"][];
      meta: components["schemas"]["utilsMetaResponse"];
    };
    /** Traces */
    Traces: {
      data: components["schemas"]["TraceWithDetails"][];
      meta: components["schemas"]["utilsMetaResponse"];
    };
    /** Sort */
    Sort: {
      id: string;
    };
    /** utilsMetaResponse */
    utilsMetaResponse: {
      /** @description current page number */
      page: number;
      /** @description number of items per page */
      limit: number;
      /** @description number of total items given the current filters/selection (if any) */
      totalItems: number;
      /** @description number of total pages given the current limit */
      totalPages: number;
    };
  };
  responses: never;
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
  datasetItems_list: {
    parameters: {
      query?: {
        datasetName?: string | null;
        sourceTraceId?: string | null;
        sourceObservationId?: string | null;
        /** @description page number, starts at 1 */
        page?: number | null;
        /** @description limit of items per page */
        limit?: number | null;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["PaginatedDatasetItems"];
        };
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      405: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
    };
  };
  datasetItems_create: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateDatasetItemRequest"];
      };
    };
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["DatasetItem"];
        };
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      405: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
    };
  };
  datasetItems_get: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["DatasetItem"];
        };
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      405: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
    };
  };
  datasetRunItems_create: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateDatasetRunItemRequest"];
      };
    };
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["DatasetRunItem"];
        };
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      405: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
    };
  };
  datasets_list: {
    parameters: {
      query?: {
        /** @description page number, starts at 1 */
        page?: number | null;
        /** @description limit of items per page */
        limit?: number | null;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["PaginatedDatasets"];
        };
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      405: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
    };
  };
  datasets_create: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateDatasetRequest"];
      };
    };
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Dataset"];
        };
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      405: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
    };
  };
  datasets_get: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        datasetName: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Dataset"];
        };
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      405: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
    };
  };
  datasets_getRun: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        datasetName: string;
        runName: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["DatasetRunWithItems"];
        };
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      405: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
    };
  };
  datasets_getRuns: {
    parameters: {
      query?: {
        /** @description page number, starts at 1 */
        page?: number | null;
        /** @description limit of items per page */
        limit?: number | null;
      };
      header?: never;
      path: {
        datasetName: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["PaginatedDatasetRuns"];
        };
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      405: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
    };
  };
  health_health: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["HealthResponse"];
        };
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      405: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      503: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  ingestion_batch: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description Batch of tracing events to be ingested. Discriminated by attribute `type`. */
          batch: components["schemas"]["IngestionEvent"][];
          /** @description Optional. Metadata field used by the Langfuse SDKs for debugging. */
          metadata?: unknown;
        };
      };
    };
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["IngestionResponse"];
        };
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      405: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
    };
  };
  metrics_daily: {
    parameters: {
      query?: {
        /** @description page number, starts at 1 */
        page?: number | null;
        /** @description limit of items per page */
        limit?: number | null;
        /** @description Optional filter by the name of the trace */
        traceName?: string | null;
        /** @description Optional filter by the userId associated with the trace */
        userId?: string | null;
        /** @description Optional filter for metrics where traces include all of these tags */
        tags?: (string | null)[];
        /** @description Optional filter to only include traces on or after a certain datetime (ISO 8601) */
        fromTimestamp?: string | null;
        /** @description Optional filter to only include traces before a certain datetime (ISO 8601) */
        toTimestamp?: string | null;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["DailyMetrics"];
        };
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      405: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
    };
  };
  observations_get: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique langfuse identifier of an observation, can be an event, span or generation */
        observationId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["ObservationsView"];
        };
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      405: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
    };
  };
  observations_getMany: {
    parameters: {
      query?: {
        /** @description Page number, starts at 1. */
        page?: number | null;
        /** @description Limit of items per page. If you encounter api issues due to too large page sizes, try to reduce the limit. */
        limit?: number | null;
        name?: string | null;
        userId?: string | null;
        type?: string | null;
        traceId?: string | null;
        parentObservationId?: string | null;
        /** @description Retrieve only observations with a start_time greater than this datetime (ISO 8601). */
        fromStartTime?: string | null;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["ObservationsViews"];
        };
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      405: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
    };
  };
  projects_get: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Projects"];
        };
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      405: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
    };
  };
  prompts_get: {
    parameters: {
      query?: {
        /** @description Version of the prompt to be retrieved. */
        version?: number | null;
        /** @description Label of the prompt to be retrieved. Defaults to "production" if no label or version is set. */
        label?: string | null;
      };
      header?: never;
      path: {
        /** @description The name of the prompt */
        promptName: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Prompt"];
        };
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      405: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
    };
  };
  prompts_list: {
    parameters: {
      query?: {
        name?: string | null;
        label?: string | null;
        tag?: string | null;
        /** @description page number, starts at 1 */
        page?: number | null;
        /** @description limit of items per page */
        limit?: number | null;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["PromptMetaListResponse"];
        };
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      405: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
    };
  };
  prompts_create: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreatePromptRequest"];
      };
    };
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Prompt"];
        };
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      405: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
    };
  };
  scoreConfigs_get: {
    parameters: {
      query?: {
        /** @description Page number, starts at 1. */
        page?: number | null;
        /** @description Limit of items per page. If you encounter api issues due to too large page sizes, try to reduce the limit. */
        limit?: number | null;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["ScoreConfigs"];
        };
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      405: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
    };
  };
  "scoreConfigs_get-by-id": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique langfuse identifier of a score config */
        configId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["ScoreConfig"];
        };
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      405: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
    };
  };
  score_get: {
    parameters: {
      query?: {
        /** @description Page number, starts at 1. */
        page?: number | null;
        /** @description Limit of items per page. If you encounter api issues due to too large page sizes, try to reduce the limit. */
        limit?: number | null;
        userId?: string | null;
        name?: string | null;
        /** @description Retrieve only scores newer than this datetime (ISO 8601). */
        fromTimestamp?: string | null;
        /** @description Retrieve only scores from a specific source. */
        source?: components["schemas"]["ScoreSource"];
        /** @description Retrieve only scores with <operator> value. */
        operator?: string | null;
        /** @description Retrieve only scores with <operator> value. */
        value?: number | null;
        /** @description Comma-separated list of score IDs to limit the results to. */
        scoreIds?: string | null;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Scores"];
        };
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      405: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
    };
  };
  score_create: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateScoreRequest"];
      };
    };
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Score"];
        };
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      405: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
    };
  };
  "score_get-by-id": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique langfuse identifier of a score */
        scoreId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Score"];
        };
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      405: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
    };
  };
  score_delete: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique langfuse identifier of a score */
        scoreId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      405: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
    };
  };
  sessions_get: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique id of a session */
        sessionId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["SessionWithTraces"];
        };
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      405: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
    };
  };
  trace_get: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique langfuse identifier of a trace */
        traceId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["TraceWithFullDetails"];
        };
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      405: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
    };
  };
  trace_list: {
    parameters: {
      query?: {
        /** @description Page number, starts at 1 */
        page?: number | null;
        /** @description Limit of items per page. If you encounter api issues due to too large page sizes, try to reduce the limit. */
        limit?: number | null;
        userId?: string | null;
        name?: string | null;
        sessionId?: string | null;
        /** @description Retrieve only traces newer than this datetime (ISO 8601). */
        fromTimestamp?: string | null;
        /** @description Format of the string [field].[asc/desc]. Fields: id, timestamp, name, userId, release, version, public, bookmarked, sessionId. Example: timestamp.asc */
        orderBy?: string | null;
        /** @description Only traces that include all of these tags will be returned. */
        tags?: (string | null)[];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Traces"];
        };
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      405: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
    };
  };
}
