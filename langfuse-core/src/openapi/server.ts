/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  "/api/public/comments": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Get all comments */
    get: operations["comments_get"];
    put?: never;
    /** @description Create a comment. Comments may be attached to different object types (trace, observation, session, prompt). */
    post: operations["comments_create"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/public/comments/{commentId}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Get a comment by id */
    get: operations["comments_get-by-id"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/public/dataset-items": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Get dataset items */
    get: operations["datasetItems_list"];
    put?: never;
    /** @description Create a dataset item */
    post: operations["datasetItems_create"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/public/dataset-items/{id}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Get a dataset item */
    get: operations["datasetItems_get"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/public/dataset-run-items": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** @description Create a dataset run item */
    post: operations["datasetRunItems_create"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/public/v2/datasets": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Get all datasets */
    get: operations["datasets_list"];
    put?: never;
    /** @description Create a dataset */
    post: operations["datasets_create"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/public/v2/datasets/{datasetName}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Get a dataset */
    get: operations["datasets_get"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/public/datasets/{datasetName}/runs/{runName}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Get a dataset run and its items */
    get: operations["datasets_getRun"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/public/datasets/{datasetName}/runs": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Get dataset runs */
    get: operations["datasets_getRuns"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/public/health": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Check health of API and database */
    get: operations["health_health"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/public/ingestion": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** @description Batched ingestion for Langfuse Tracing. If you want to use tracing via the API, such as to build your own Langfuse client implementation, this is the only API route you need to implement.
     *
     *     Notes:
     *
     *     - Introduction to data model: https://langfuse.com/docs/tracing-data-model
     *     - Batch sizes are limited to 3.5 MB in total. You need to adjust the number of events per batch accordingly.
     *     - The API does not return a 4xx status code for input errors. Instead, it responds with a 207 status code, which includes a list of the encountered errors. */
    post: operations["ingestion_batch"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/public/media/{mediaId}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Get a media record */
    get: operations["media_get"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    /** @description Patch a media record */
    patch: operations["media_patch"];
    trace?: never;
  };
  "/api/public/media": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** @description Get a presigned upload URL for a media record */
    post: operations["media_getUploadUrl"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/public/metrics/daily": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Get daily metrics of the Langfuse project */
    get: operations["metrics_daily"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/public/models": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Get all models */
    get: operations["models_list"];
    put?: never;
    /** @description Create a model */
    post: operations["models_create"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/public/models/{id}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Get a model */
    get: operations["models_get"];
    put?: never;
    post?: never;
    /** @description Delete a model. Cannot delete models managed by Langfuse. You can create your own definition with the same modelName to override the definition though. */
    delete: operations["models_delete"];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/public/observations/{observationId}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Get a observation */
    get: operations["observations_get"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/public/observations": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Get a list of observations */
    get: operations["observations_getMany"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/public/projects": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Get Project associated with API key */
    get: operations["projects_get"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/public/v2/prompts/{promptName}/version/{version}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    /** @description Update labels for a specific prompt version */
    patch: operations["promptVersion_update"];
    trace?: never;
  };
  "/api/public/v2/prompts/{promptName}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Get a prompt */
    get: operations["prompts_get"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/public/v2/prompts": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Get a list of prompt names with versions and labels */
    get: operations["prompts_list"];
    put?: never;
    /** @description Create a new version for the prompt with the given `name` */
    post: operations["prompts_create"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/public/score-configs": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Get all score configs */
    get: operations["scoreConfigs_get"];
    put?: never;
    /** @description Create a score configuration (config). Score configs are used to define the structure of scores */
    post: operations["scoreConfigs_create"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/public/score-configs/{configId}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Get a score config */
    get: operations["scoreConfigs_get-by-id"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/public/scores": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Get a list of scores */
    get: operations["score_get"];
    put?: never;
    /** @description Create a score */
    post: operations["score_create"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/public/scores/{scoreId}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Get a score */
    get: operations["score_get-by-id"];
    put?: never;
    post?: never;
    /** @description Delete a score */
    delete: operations["score_delete"];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/public/sessions": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Get sessions */
    get: operations["sessions_list"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/public/sessions/{sessionId}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Get a session. Please note that `traces` on this endpoint are not paginated, if you plan to fetch large sessions, consider `GET /api/public/traces?sessionId=<sessionId>` */
    get: operations["sessions_get"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/public/traces/{traceId}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Get a specific trace */
    get: operations["trace_get"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/public/traces": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Get list of traces */
    get: operations["trace_list"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
}
export type webhooks = Record<string, never>;
export interface components {
  schemas: {
    /** CreateCommentRequest */
    CreateCommentRequest: {
      /** @description The id of the project to attach the comment to. */
      projectId: string;
      /** @description The type of the object to attach the comment to (trace, observation, session, prompt). */
      objectType: string;
      /** @description The id of the object to attach the comment to. If this does not reference a valid existing object, an error will be thrown. */
      objectId: string;
      /** @description The content of the comment. May include markdown. Currently limited to 3000 characters. */
      content: string;
      /** @description The id of the user who created the comment. */
      authorUserId?: string | null;
    };
    /** CreateCommentResponse */
    CreateCommentResponse: {
      /** @description The id of the created object in Langfuse */
      id: string;
    };
    /** GetCommentsResponse */
    GetCommentsResponse: {
      data: components["schemas"]["Comment"][];
      meta: components["schemas"]["utilsMetaResponse"];
    };
    /** Trace */
    Trace: {
      /** @description The unique identifier of a trace */
      id: string;
      /**
       * Format: date-time
       * @description The timestamp when the trace was created
       */
      timestamp: string;
      /** @description The name of the trace */
      name?: string | null;
      /** @description The input data of the trace. Can be any JSON. */
      input?: unknown;
      /** @description The output data of the trace. Can be any JSON. */
      output?: unknown;
      /** @description The session identifier associated with the trace */
      sessionId?: string | null;
      /** @description The release version of the application when the trace was created */
      release?: string | null;
      /** @description The version of the trace */
      version?: string | null;
      /** @description The user identifier associated with the trace */
      userId?: string | null;
      /** @description The metadata associated with the trace. Can be any JSON. */
      metadata?: unknown;
      /** @description The tags associated with the trace. Can be an array of strings or null. */
      tags?: string[] | null;
      /** @description Public traces are accessible via url without login */
      public?: boolean | null;
    };
    /** TraceWithDetails */
    TraceWithDetails: {
      /** @description Path of trace in Langfuse UI */
      htmlPath: string;
      /**
       * Format: double
       * @description Latency of trace in seconds
       */
      latency: number;
      /**
       * Format: double
       * @description Cost of trace in USD
       */
      totalCost: number;
      /** @description List of observation ids */
      observations: string[];
      /** @description List of score ids */
      scores: string[];
    } & components["schemas"]["Trace"];
    /** TraceWithFullDetails */
    TraceWithFullDetails: {
      /** @description Path of trace in Langfuse UI */
      htmlPath: string;
      /**
       * Format: double
       * @description Latency of trace in seconds
       */
      latency: number;
      /**
       * Format: double
       * @description Cost of trace in USD
       */
      totalCost: number;
      /** @description List of observations */
      observations: components["schemas"]["ObservationsView"][];
      /** @description List of scores */
      scores: components["schemas"]["Score"][];
    } & components["schemas"]["Trace"];
    /** Session */
    Session: {
      id: string;
      /** Format: date-time */
      createdAt: string;
      projectId: string;
    };
    /** SessionWithTraces */
    SessionWithTraces: {
      traces: components["schemas"]["Trace"][];
    } & components["schemas"]["Session"];
    /** Observation */
    Observation: {
      /** @description The unique identifier of the observation */
      id: string;
      /** @description The trace ID associated with the observation */
      traceId?: string | null;
      /** @description The type of the observation */
      type: string;
      /** @description The name of the observation */
      name?: string | null;
      /**
       * Format: date-time
       * @description The start time of the observation
       */
      startTime: string;
      /**
       * Format: date-time
       * @description The end time of the observation.
       */
      endTime?: string | null;
      /**
       * Format: date-time
       * @description The completion start time of the observation
       */
      completionStartTime?: string | null;
      /** @description The model used for the observation */
      model?: string | null;
      /** @description The parameters of the model used for the observation */
      modelParameters?: {
        [key: string]: components["schemas"]["MapValue"];
      } | null;
      /** @description The input data of the observation */
      input?: unknown;
      /** @description The version of the observation */
      version?: string | null;
      /** @description Additional metadata of the observation */
      metadata?: unknown;
      /** @description The output data of the observation */
      output?: unknown;
      /** @description (Deprecated. Use usageDetails and costDetails instead.) The usage data of the observation */
      usage?: components["schemas"]["Usage"];
      /** @description The level of the observation */
      level: components["schemas"]["ObservationLevel"];
      /** @description The status message of the observation */
      statusMessage?: string | null;
      /** @description The parent observation ID */
      parentObservationId?: string | null;
      /** @description The prompt ID associated with the observation */
      promptId?: string | null;
      /** @description The usage details of the observation. Key is the name of the usage metric, value is the number of units consumed. The total key is the sum of all (non-total) usage metrics or the total value ingested. */
      usageDetails?: {
        [key: string]: number;
      } | null;
      /** @description The cost details of the observation. Key is the name of the cost metric, value is the cost in USD. The total key is the sum of all (non-total) cost metrics or the total value ingested. */
      costDetails?: {
        [key: string]: number;
      } | null;
    };
    /** ObservationsView */
    ObservationsView: {
      /** @description The name of the prompt associated with the observation */
      promptName?: string | null;
      /** @description The version of the prompt associated with the observation */
      promptVersion?: number | null;
      /** @description The unique identifier of the model */
      modelId?: string | null;
      /**
       * Format: double
       * @description The price of the input in USD
       */
      inputPrice?: number | null;
      /**
       * Format: double
       * @description The price of the output in USD.
       */
      outputPrice?: number | null;
      /**
       * Format: double
       * @description The total price in USD.
       */
      totalPrice?: number | null;
      /**
       * Format: double
       * @description (Deprecated. Use usageDetails and costDetails instead.) The calculated cost of the input in USD
       */
      calculatedInputCost?: number | null;
      /**
       * Format: double
       * @description (Deprecated. Use usageDetails and costDetails instead.) The calculated cost of the output in USD
       */
      calculatedOutputCost?: number | null;
      /**
       * Format: double
       * @description (Deprecated. Use usageDetails and costDetails instead.) The calculated total cost in USD
       */
      calculatedTotalCost?: number | null;
      /**
       * Format: double
       * @description The latency in seconds.
       */
      latency?: number | null;
      /**
       * Format: double
       * @description The time to the first token in seconds
       */
      timeToFirstToken?: number | null;
    } & components["schemas"]["Observation"];
    /**
     * Usage
     * @description (Deprecated. Use usageDetails and costDetails instead.) Standard interface for usage and cost
     */
    Usage: {
      /** @description Number of input units (e.g. tokens) */
      input?: number | null;
      /** @description Number of output units (e.g. tokens) */
      output?: number | null;
      /** @description Defaults to input+output if not set */
      total?: number | null;
      unit?: components["schemas"]["ModelUsageUnit"];
      /**
       * Format: double
       * @description USD input cost
       */
      inputCost?: number | null;
      /**
       * Format: double
       * @description USD output cost
       */
      outputCost?: number | null;
      /**
       * Format: double
       * @description USD total cost, defaults to input+output
       */
      totalCost?: number | null;
    };
    /**
     * ScoreConfig
     * @description Configuration for a score
     */
    ScoreConfig: {
      id: string;
      name: string;
      /** Format: date-time */
      createdAt: string;
      /** Format: date-time */
      updatedAt: string;
      projectId: string;
      dataType: components["schemas"]["ScoreDataType"];
      /** @description Whether the score config is archived. Defaults to false */
      isArchived: boolean;
      /**
       * Format: double
       * @description Sets minimum value for numerical scores. If not set, the minimum value defaults to -∞
       */
      minValue?: number | null;
      /**
       * Format: double
       * @description Sets maximum value for numerical scores. If not set, the maximum value defaults to +∞
       */
      maxValue?: number | null;
      /** @description Configures custom categories for categorical scores */
      categories?: components["schemas"]["ConfigCategory"][] | null;
      description?: string | null;
    };
    /** ConfigCategory */
    ConfigCategory: {
      /** Format: double */
      value: number;
      label: string;
    };
    /** BaseScore */
    BaseScore: {
      id: string;
      traceId: string;
      name: string;
      source: components["schemas"]["ScoreSource"];
      observationId?: string | null;
      /** Format: date-time */
      timestamp: string;
      /** Format: date-time */
      createdAt: string;
      /** Format: date-time */
      updatedAt: string;
      authorUserId?: string | null;
      comment?: string | null;
      /** @description Reference a score config on a score. When set, config and score name must be equal and value must comply to optionally defined numerical range */
      configId?: string | null;
      /** @description Reference an annotation queue on a score. Populated if the score was initially created in an annotation queue. */
      queueId?: string | null;
    };
    /** NumericScore */
    NumericScore: {
      /**
       * Format: double
       * @description The numeric value of the score
       */
      value: number;
    } & components["schemas"]["BaseScore"];
    /** BooleanScore */
    BooleanScore: {
      /**
       * Format: double
       * @description The numeric value of the score. Equals 1 for "True" and 0 for "False"
       */
      value: number;
      /** @description The string representation of the score value. Is inferred from the numeric value and equals "True" or "False" */
      stringValue: string;
    } & components["schemas"]["BaseScore"];
    /** CategoricalScore */
    CategoricalScore: {
      /**
       * Format: double
       * @description Only defined if a config is linked. Represents the numeric category mapping of the stringValue
       */
      value?: number | null;
      /** @description The string representation of the score value. If no config is linked, can be any string. Otherwise, must map to a config category */
      stringValue: string;
    } & components["schemas"]["BaseScore"];
    /** Score */
    Score:
      | ({
          /** @enum {string} */
          dataType: "NUMERIC";
        } & components["schemas"]["NumericScore"])
      | ({
          /** @enum {string} */
          dataType: "CATEGORICAL";
        } & components["schemas"]["CategoricalScore"])
      | ({
          /** @enum {string} */
          dataType: "BOOLEAN";
        } & components["schemas"]["BooleanScore"]);
    /**
     * CreateScoreValue
     * @description The value of the score. Must be passed as string for categorical scores, and numeric for boolean and numeric scores
     */
    CreateScoreValue: number | string;
    /** Comment */
    Comment: {
      id: string;
      projectId: string;
      /** Format: date-time */
      createdAt: string;
      /** Format: date-time */
      updatedAt: string;
      objectType: components["schemas"]["CommentObjectType"];
      objectId: string;
      content: string;
      authorUserId?: string | null;
    };
    /** Dataset */
    Dataset: {
      id: string;
      name: string;
      description?: string | null;
      metadata?: unknown;
      projectId: string;
      /** Format: date-time */
      createdAt: string;
      /** Format: date-time */
      updatedAt: string;
    };
    /** DatasetItem */
    DatasetItem: {
      id: string;
      status: components["schemas"]["DatasetStatus"];
      input?: unknown;
      expectedOutput?: unknown;
      metadata?: unknown;
      sourceTraceId?: string | null;
      sourceObservationId?: string | null;
      datasetId: string;
      datasetName: string;
      /** Format: date-time */
      createdAt: string;
      /** Format: date-time */
      updatedAt: string;
    };
    /** DatasetRunItem */
    DatasetRunItem: {
      id: string;
      datasetRunId: string;
      datasetRunName: string;
      datasetItemId: string;
      traceId: string;
      observationId?: string | null;
      /** Format: date-time */
      createdAt: string;
      /** Format: date-time */
      updatedAt: string;
    };
    /** DatasetRun */
    DatasetRun: {
      /** @description Unique identifier of the dataset run */
      id: string;
      /** @description Name of the dataset run */
      name: string;
      /** @description Description of the run */
      description?: string | null;
      /** @description Metadata of the dataset run */
      metadata?: unknown;
      /** @description Id of the associated dataset */
      datasetId: string;
      /** @description Name of the associated dataset */
      datasetName: string;
      /**
       * Format: date-time
       * @description The date and time when the dataset run was created
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description The date and time when the dataset run was last updated
       */
      updatedAt: string;
    };
    /** DatasetRunWithItems */
    DatasetRunWithItems: {
      datasetRunItems: components["schemas"]["DatasetRunItem"][];
    } & components["schemas"]["DatasetRun"];
    /**
     * Model
     * @description Model definition used for transforming usage into USD cost and/or tokenization.
     */
    Model: {
      id: string;
      /** @description Name of the model definition. If multiple with the same name exist, they are applied in the following order: (1) custom over built-in, (2) newest according to startTime where model.startTime<observation.startTime */
      modelName: string;
      /** @description Regex pattern which matches this model definition to generation.model. Useful in case of fine-tuned models. If you want to exact match, use `(?i)^modelname$` */
      matchPattern: string;
      /**
       * Format: date-time
       * @description Apply only to generations which are newer than this ISO date.
       */
      startDate?: string | null;
      /** @description Unit used by this model. */
      unit?: components["schemas"]["ModelUsageUnit"];
      /**
       * Format: double
       * @description Price (USD) per input unit
       */
      inputPrice?: number | null;
      /**
       * Format: double
       * @description Price (USD) per output unit
       */
      outputPrice?: number | null;
      /**
       * Format: double
       * @description Price (USD) per total unit. Cannot be set if input or output price is set.
       */
      totalPrice?: number | null;
      /** @description Optional. Tokenizer to be applied to observations which match to this model. See docs for more details. */
      tokenizerId?: string | null;
      /** @description Optional. Configuration for the selected tokenizer. Needs to be JSON. See docs for more details. */
      tokenizerConfig?: unknown;
      isLangfuseManaged: boolean;
    };
    /**
     * ModelUsageUnit
     * @description Unit of usage in Langfuse
     * @enum {string}
     */
    ModelUsageUnit: "CHARACTERS" | "TOKENS" | "MILLISECONDS" | "SECONDS" | "IMAGES" | "REQUESTS";
    /**
     * ObservationLevel
     * @enum {string}
     */
    ObservationLevel: "DEBUG" | "DEFAULT" | "WARNING" | "ERROR";
    /** MapValue */
    MapValue: (string | null) | (number | null) | (boolean | null) | (string[] | null);
    /**
     * CommentObjectType
     * @enum {string}
     */
    CommentObjectType: "TRACE" | "OBSERVATION" | "SESSION" | "PROMPT";
    /**
     * DatasetStatus
     * @enum {string}
     */
    DatasetStatus: "ACTIVE" | "ARCHIVED";
    /**
     * ScoreSource
     * @enum {string}
     */
    ScoreSource: "ANNOTATION" | "API" | "EVAL";
    /**
     * ScoreDataType
     * @enum {string}
     */
    ScoreDataType: "NUMERIC" | "BOOLEAN" | "CATEGORICAL";
    /** CreateDatasetItemRequest */
    CreateDatasetItemRequest: {
      datasetName: string;
      input?: unknown;
      expectedOutput?: unknown;
      metadata?: unknown;
      sourceTraceId?: string | null;
      sourceObservationId?: string | null;
      /** @description Dataset items are upserted on their id. Id needs to be unique (project-level) and cannot be reused across datasets. */
      id?: string | null;
      /** @description Defaults to ACTIVE for newly created items */
      status?: components["schemas"]["DatasetStatus"];
    };
    /** PaginatedDatasetItems */
    PaginatedDatasetItems: {
      data: components["schemas"]["DatasetItem"][];
      meta: components["schemas"]["utilsMetaResponse"];
    };
    /** CreateDatasetRunItemRequest */
    CreateDatasetRunItemRequest: {
      runName: string;
      /** @description Description of the run. If run exists, description will be updated. */
      runDescription?: string | null;
      /** @description Metadata of the dataset run, updates run if run already exists */
      metadata?: unknown;
      datasetItemId: string;
      observationId?: string | null;
      /** @description traceId should always be provided. For compatibility with older SDK versions it can also be inferred from the provided observationId. */
      traceId?: string | null;
    };
    /** PaginatedDatasets */
    PaginatedDatasets: {
      data: components["schemas"]["Dataset"][];
      meta: components["schemas"]["utilsMetaResponse"];
    };
    /** CreateDatasetRequest */
    CreateDatasetRequest: {
      name: string;
      description?: string | null;
      metadata?: unknown;
    };
    /** PaginatedDatasetRuns */
    PaginatedDatasetRuns: {
      data: components["schemas"]["DatasetRun"][];
      meta: components["schemas"]["utilsMetaResponse"];
    };
    /** HealthResponse */
    HealthResponse: {
      /**
       * @description Langfuse server version
       * @example 1.25.0
       */
      version: string;
      /** @example OK */
      status: string;
    };
    /** IngestionEvent */
    IngestionEvent:
      | ({
          /** @enum {string} */
          type: "trace-create";
        } & components["schemas"]["TraceEvent"])
      | ({
          /** @enum {string} */
          type: "score-create";
        } & components["schemas"]["ScoreEvent"])
      | ({
          /** @enum {string} */
          type: "span-create";
        } & components["schemas"]["CreateSpanEvent"])
      | ({
          /** @enum {string} */
          type: "span-update";
        } & components["schemas"]["UpdateSpanEvent"])
      | ({
          /** @enum {string} */
          type: "generation-create";
        } & components["schemas"]["CreateGenerationEvent"])
      | ({
          /** @enum {string} */
          type: "generation-update";
        } & components["schemas"]["UpdateGenerationEvent"])
      | ({
          /** @enum {string} */
          type: "event-create";
        } & components["schemas"]["CreateEventEvent"])
      | ({
          /** @enum {string} */
          type: "sdk-log";
        } & components["schemas"]["SDKLogEvent"])
      | ({
          /** @enum {string} */
          type: "observation-create";
        } & components["schemas"]["CreateObservationEvent"])
      | ({
          /** @enum {string} */
          type: "observation-update";
        } & components["schemas"]["UpdateObservationEvent"]);
    /**
     * ObservationType
     * @enum {string}
     */
    ObservationType: "SPAN" | "GENERATION" | "EVENT";
    /** IngestionUsage */
    IngestionUsage: components["schemas"]["Usage"] | components["schemas"]["OpenAIUsage"];
    /**
     * OpenAIUsage
     * @description Usage interface of OpenAI for improved compatibility.
     */
    OpenAIUsage: {
      promptTokens?: number | null;
      completionTokens?: number | null;
      totalTokens?: number | null;
    };
    /** OptionalObservationBody */
    OptionalObservationBody: {
      traceId?: string | null;
      name?: string | null;
      /** Format: date-time */
      startTime?: string | null;
      metadata?: unknown;
      input?: unknown;
      output?: unknown;
      level?: components["schemas"]["ObservationLevel"];
      statusMessage?: string | null;
      parentObservationId?: string | null;
      version?: string | null;
    };
    /** CreateEventBody */
    CreateEventBody: {
      id?: string | null;
    } & components["schemas"]["OptionalObservationBody"];
    /** UpdateEventBody */
    UpdateEventBody: {
      id: string;
    } & components["schemas"]["OptionalObservationBody"];
    /** CreateSpanBody */
    CreateSpanBody: {
      /** Format: date-time */
      endTime?: string | null;
    } & components["schemas"]["CreateEventBody"];
    /** UpdateSpanBody */
    UpdateSpanBody: {
      /** Format: date-time */
      endTime?: string | null;
    } & components["schemas"]["UpdateEventBody"];
    /** CreateGenerationBody */
    CreateGenerationBody: {
      /** Format: date-time */
      completionStartTime?: string | null;
      model?: string | null;
      modelParameters?: {
        [key: string]: components["schemas"]["MapValue"];
      } | null;
      usage?: components["schemas"]["IngestionUsage"];
      usageDetails?: components["schemas"]["UsageDetails"];
      costDetails?: {
        [key: string]: number;
      } | null;
      promptName?: string | null;
      promptVersion?: number | null;
    } & components["schemas"]["CreateSpanBody"];
    /** UpdateGenerationBody */
    UpdateGenerationBody: {
      /** Format: date-time */
      completionStartTime?: string | null;
      model?: string | null;
      modelParameters?: {
        [key: string]: components["schemas"]["MapValue"];
      } | null;
      usage?: components["schemas"]["IngestionUsage"];
      promptName?: string | null;
      usageDetails?: components["schemas"]["UsageDetails"];
      costDetails?: {
        [key: string]: number;
      } | null;
      promptVersion?: number | null;
    } & components["schemas"]["UpdateSpanBody"];
    /** ObservationBody */
    ObservationBody: {
      id?: string | null;
      traceId?: string | null;
      type: components["schemas"]["ObservationType"];
      name?: string | null;
      /** Format: date-time */
      startTime?: string | null;
      /** Format: date-time */
      endTime?: string | null;
      /** Format: date-time */
      completionStartTime?: string | null;
      model?: string | null;
      modelParameters?: {
        [key: string]: components["schemas"]["MapValue"];
      } | null;
      input?: unknown;
      version?: string | null;
      metadata?: unknown;
      output?: unknown;
      usage?: components["schemas"]["Usage"];
      level?: components["schemas"]["ObservationLevel"];
      statusMessage?: string | null;
      parentObservationId?: string | null;
    };
    /** TraceBody */
    TraceBody: {
      id?: string | null;
      /** Format: date-time */
      timestamp?: string | null;
      name?: string | null;
      userId?: string | null;
      input?: unknown;
      output?: unknown;
      sessionId?: string | null;
      release?: string | null;
      version?: string | null;
      metadata?: unknown;
      tags?: string[] | null;
      /** @description Make trace publicly accessible via url */
      public?: boolean | null;
    };
    /** SDKLogBody */
    SDKLogBody: {
      log: unknown;
    };
    /** ScoreBody */
    ScoreBody: {
      id?: string | null;
      /** @example cdef-1234-5678-90ab */
      traceId: string;
      /** @example novelty */
      name: string;
      /** @description The value of the score. Must be passed as string for categorical scores, and numeric for boolean and numeric scores. Boolean score values must equal either 1 or 0 (true or false) */
      value: components["schemas"]["CreateScoreValue"];
      observationId?: string | null;
      comment?: string | null;
      /** @description When set, must match the score value's type. If not set, will be inferred from the score value or config */
      dataType?: components["schemas"]["ScoreDataType"];
      /** @description Reference a score config on a score. When set, the score name must equal the config name and scores must comply with the config's range and data type. For categorical scores, the value must map to a config category. Numeric scores might be constrained by the score config's max and min values */
      configId?: string | null;
    };
    /** BaseEvent */
    BaseEvent: {
      /** @description UUID v4 that identifies the event */
      id: string;
      /** @description Datetime (ISO 8601) of event creation in client. Should be as close to actual event creation in client as possible, this timestamp will be used for ordering of events in future release. Resolution: milliseconds (required), microseconds (optimal). */
      timestamp: string;
      /** @description Optional. Metadata field used by the Langfuse SDKs for debugging. */
      metadata?: unknown;
    };
    /** TraceEvent */
    TraceEvent: {
      body: components["schemas"]["TraceBody"];
    } & components["schemas"]["BaseEvent"];
    /** CreateObservationEvent */
    CreateObservationEvent: {
      body: components["schemas"]["ObservationBody"];
    } & components["schemas"]["BaseEvent"];
    /** UpdateObservationEvent */
    UpdateObservationEvent: {
      body: components["schemas"]["ObservationBody"];
    } & components["schemas"]["BaseEvent"];
    /** ScoreEvent */
    ScoreEvent: {
      body: components["schemas"]["ScoreBody"];
    } & components["schemas"]["BaseEvent"];
    /** SDKLogEvent */
    SDKLogEvent: {
      body: components["schemas"]["SDKLogBody"];
    } & components["schemas"]["BaseEvent"];
    /** CreateGenerationEvent */
    CreateGenerationEvent: {
      body: components["schemas"]["CreateGenerationBody"];
    } & components["schemas"]["BaseEvent"];
    /** UpdateGenerationEvent */
    UpdateGenerationEvent: {
      body: components["schemas"]["UpdateGenerationBody"];
    } & components["schemas"]["BaseEvent"];
    /** CreateSpanEvent */
    CreateSpanEvent: {
      body: components["schemas"]["CreateSpanBody"];
    } & components["schemas"]["BaseEvent"];
    /** UpdateSpanEvent */
    UpdateSpanEvent: {
      body: components["schemas"]["UpdateSpanBody"];
    } & components["schemas"]["BaseEvent"];
    /** CreateEventEvent */
    CreateEventEvent: {
      body: components["schemas"]["CreateEventBody"];
    } & components["schemas"]["BaseEvent"];
    /** IngestionSuccess */
    IngestionSuccess: {
      id: string;
      status: number;
    };
    /** IngestionError */
    IngestionError: {
      id: string;
      status: number;
      message?: string | null;
      error?: unknown;
    };
    /** IngestionResponse */
    IngestionResponse: {
      successes: components["schemas"]["IngestionSuccess"][];
      errors: components["schemas"]["IngestionError"][];
    };
    /** OpenAIUsageSchema */
    OpenAIUsageSchema: {
      prompt_tokens: number;
      completion_tokens: number;
      total_tokens: number;
      prompt_tokens_details?: {
        [key: string]: number;
      } | null;
      completion_tokens_details?: {
        [key: string]: number;
      } | null;
    };
    /** UsageDetails */
    UsageDetails:
      | {
          [key: string]: number;
        }
      | components["schemas"]["OpenAIUsageSchema"];
    /** GetMediaResponse */
    GetMediaResponse: {
      /** @description The unique langfuse identifier of a media record */
      mediaId: string;
      /** @description The MIME type of the media record */
      contentType: string;
      /** @description The size of the media record in bytes */
      contentLength: number;
      /**
       * Format: date-time
       * @description The date and time when the media record was uploaded
       */
      uploadedAt: string;
      /** @description The download URL of the media record */
      url: string;
      /** @description The expiry date and time of the media record download URL */
      urlExpiry: string;
    };
    /** PatchMediaBody */
    PatchMediaBody: {
      /**
       * Format: date-time
       * @description The date and time when the media record was uploaded
       */
      uploadedAt: string;
      /** @description The HTTP status code of the upload */
      uploadHttpStatus: number;
      /** @description The HTTP error message of the upload */
      uploadHttpError?: string | null;
      /** @description The time in milliseconds it took to upload the media record */
      uploadTimeMs?: number | null;
    };
    /** GetMediaUploadUrlRequest */
    GetMediaUploadUrlRequest: {
      /** @description The trace ID associated with the media record */
      traceId: string;
      /** @description The observation ID associated with the media record. If the media record is associated directly with a trace, this will be null. */
      observationId?: string | null;
      contentType: components["schemas"]["MediaContentType"];
      /** @description The size of the media record in bytes */
      contentLength: number;
      /** @description The SHA-256 hash of the media record */
      sha256Hash: string;
      /** @description The trace / observation field the media record is associated with. This can be one of `input`, `output`, `metadata` */
      field: string;
    };
    /** GetMediaUploadUrlResponse */
    GetMediaUploadUrlResponse: {
      /** @description The presigned upload URL. If the asset is already uploaded, this will be null */
      uploadUrl?: string | null;
      /** @description The unique langfuse identifier of a media record */
      mediaId: string;
    };
    /**
     * MediaContentType
     * @description The MIME type of the media record
     * @enum {string}
     */
    MediaContentType:
      | "image/png"
      | "image/jpeg"
      | "image/jpg"
      | "image/webp"
      | "image/gif"
      | "image/svg+xml"
      | "image/tiff"
      | "image/bmp"
      | "audio/mpeg"
      | "audio/mp3"
      | "audio/wav"
      | "audio/ogg"
      | "audio/oga"
      | "audio/aac"
      | "audio/mp4"
      | "audio/flac"
      | "video/mp4"
      | "video/webm"
      | "text/plain"
      | "text/html"
      | "text/css"
      | "text/csv"
      | "application/pdf"
      | "application/msword"
      | "application/vnd.ms-excel"
      | "application/zip"
      | "application/json"
      | "application/xml"
      | "application/octet-stream";
    /** DailyMetrics */
    DailyMetrics: {
      /** @description A list of daily metrics, only days with ingested data are included. */
      data: components["schemas"]["DailyMetricsDetails"][];
      meta: components["schemas"]["utilsMetaResponse"];
    };
    /** DailyMetricsDetails */
    DailyMetricsDetails: {
      /** Format: date */
      date: string;
      countTraces: number;
      countObservations: number;
      /**
       * Format: double
       * @description Total model cost in USD
       */
      totalCost: number;
      usage: components["schemas"]["UsageByModel"][];
    };
    /**
     * UsageByModel
     * @description Daily usage of a given model. Usage corresponds to the unit set for the specific model (e.g. tokens).
     */
    UsageByModel: {
      model?: string | null;
      /** @description Total number of generation input units (e.g. tokens) */
      inputUsage: number;
      /** @description Total number of generation output units (e.g. tokens) */
      outputUsage: number;
      /** @description Total number of generation total units (e.g. tokens) */
      totalUsage: number;
      countTraces: number;
      countObservations: number;
      /**
       * Format: double
       * @description Total model cost in USD
       */
      totalCost: number;
    };
    /** PaginatedModels */
    PaginatedModels: {
      data: components["schemas"]["Model"][];
      meta: components["schemas"]["utilsMetaResponse"];
    };
    /** CreateModelRequest */
    CreateModelRequest: {
      /** @description Name of the model definition. If multiple with the same name exist, they are applied in the following order: (1) custom over built-in, (2) newest according to startTime where model.startTime<observation.startTime */
      modelName: string;
      /** @description Regex pattern which matches this model definition to generation.model. Useful in case of fine-tuned models. If you want to exact match, use `(?i)^modelname$` */
      matchPattern: string;
      /**
       * Format: date-time
       * @description Apply only to generations which are newer than this ISO date.
       */
      startDate?: string | null;
      /** @description Unit used by this model. */
      unit?: components["schemas"]["ModelUsageUnit"];
      /**
       * Format: double
       * @description Price (USD) per input unit
       */
      inputPrice?: number | null;
      /**
       * Format: double
       * @description Price (USD) per output unit
       */
      outputPrice?: number | null;
      /**
       * Format: double
       * @description Price (USD) per total units. Cannot be set if input or output price is set.
       */
      totalPrice?: number | null;
      /** @description Optional. Tokenizer to be applied to observations which match to this model. See docs for more details. */
      tokenizerId?: string | null;
      /** @description Optional. Configuration for the selected tokenizer. Needs to be JSON. See docs for more details. */
      tokenizerConfig?: unknown;
    };
    /** Observations */
    Observations: {
      data: components["schemas"]["Observation"][];
      meta: components["schemas"]["utilsMetaResponse"];
    };
    /** ObservationsViews */
    ObservationsViews: {
      data: components["schemas"]["ObservationsView"][];
      meta: components["schemas"]["utilsMetaResponse"];
    };
    /** Projects */
    Projects: {
      data: components["schemas"]["Project"][];
    };
    /** Project */
    Project: {
      id: string;
      name: string;
    };
    /** PromptMetaListResponse */
    PromptMetaListResponse: {
      data: components["schemas"]["PromptMeta"][];
      meta: components["schemas"]["utilsMetaResponse"];
    };
    /** PromptMeta */
    PromptMeta: {
      name: string;
      versions: number[];
      labels: string[];
      tags: string[];
      /** Format: date-time */
      lastUpdatedAt: string;
      /** @description Config object of the most recent prompt version that matches the filters (if any are provided) */
      lastConfig: unknown;
    };
    /** CreatePromptRequest */
    CreatePromptRequest:
      | ({
          /** @enum {string} */
          type: "chat";
        } & components["schemas"]["CreateChatPromptRequest"])
      | ({
          /** @enum {string} */
          type: "text";
        } & components["schemas"]["CreateTextPromptRequest"]);
    /** CreateChatPromptRequest */
    CreateChatPromptRequest: {
      name: string;
      prompt: components["schemas"]["ChatMessage"][];
      config?: unknown;
      /** @description List of deployment labels of this prompt version. */
      labels?: string[] | null;
      /** @description List of tags to apply to all versions of this prompt. */
      tags?: string[] | null;
    };
    /** CreateTextPromptRequest */
    CreateTextPromptRequest: {
      name: string;
      prompt: string;
      config?: unknown;
      /** @description List of deployment labels of this prompt version. */
      labels?: string[] | null;
      /** @description List of tags to apply to all versions of this prompt. */
      tags?: string[] | null;
    };
    /** Prompt */
    Prompt:
      | ({
          /** @enum {string} */
          type: "chat";
        } & components["schemas"]["ChatPrompt"])
      | ({
          /** @enum {string} */
          type: "text";
        } & components["schemas"]["TextPrompt"]);
    /** BasePrompt */
    BasePrompt: {
      name: string;
      version: number;
      config: unknown;
      /** @description List of deployment labels of this prompt version. */
      labels: string[];
      /** @description List of tags. Used to filter via UI and API. The same across versions of a prompt. */
      tags: string[];
    };
    /** ChatMessage */
    ChatMessage: {
      role: string;
      content: string;
    };
    /** TextPrompt */
    TextPrompt: {
      prompt: string;
    } & components["schemas"]["BasePrompt"];
    /** ChatPrompt */
    ChatPrompt: {
      prompt: components["schemas"]["ChatMessage"][];
    } & components["schemas"]["BasePrompt"];
    /** ScoreConfigs */
    ScoreConfigs: {
      data: components["schemas"]["ScoreConfig"][];
      meta: components["schemas"]["utilsMetaResponse"];
    };
    /** CreateScoreConfigRequest */
    CreateScoreConfigRequest: {
      name: string;
      dataType: components["schemas"]["ScoreDataType"];
      /** @description Configure custom categories for categorical scores. Pass a list of objects with `label` and `value` properties. Categories are autogenerated for boolean configs and cannot be passed */
      categories?: components["schemas"]["ConfigCategory"][] | null;
      /**
       * Format: double
       * @description Configure a minimum value for numerical scores. If not set, the minimum value defaults to -∞
       */
      minValue?: number | null;
      /**
       * Format: double
       * @description Configure a maximum value for numerical scores. If not set, the maximum value defaults to +∞
       */
      maxValue?: number | null;
      /** @description Description is shown across the Langfuse UI and can be used to e.g. explain the config categories in detail, why a numeric range was set, or provide additional context on config name or usage */
      description?: string | null;
    };
    /** CreateScoreRequest */
    CreateScoreRequest: {
      id?: string | null;
      /** @example cdef-1234-5678-90ab */
      traceId: string;
      /** @example novelty */
      name: string;
      /** @description The value of the score. Must be passed as string for categorical scores, and numeric for boolean and numeric scores. Boolean score values must equal either 1 or 0 (true or false) */
      value: components["schemas"]["CreateScoreValue"];
      observationId?: string | null;
      comment?: string | null;
      /** @description The data type of the score. When passing a configId this field is inferred. Otherwise, this field must be passed or will default to numeric. */
      dataType?: components["schemas"]["ScoreDataType"];
      /** @description Reference a score config on a score. The unique langfuse identifier of a score config. When passing this field, the dataType and stringValue fields are automatically populated. */
      configId?: string | null;
    };
    /** CreateScoreResponse */
    CreateScoreResponse: {
      /** @description The id of the created object in Langfuse */
      id: string;
    };
    /** GetScoresResponseTraceData */
    GetScoresResponseTraceData: {
      /** @description The user ID associated with the trace referenced by score */
      userId?: string | null;
      /** @description A list of tags associated with the trace referenced by score */
      tags?: string[] | null;
    };
    /** GetScoresResponseDataNumeric */
    GetScoresResponseDataNumeric: {
      trace: components["schemas"]["GetScoresResponseTraceData"];
    } & components["schemas"]["NumericScore"];
    /** GetScoresResponseDataCategorical */
    GetScoresResponseDataCategorical: {
      trace: components["schemas"]["GetScoresResponseTraceData"];
    } & components["schemas"]["CategoricalScore"];
    /** GetScoresResponseDataBoolean */
    GetScoresResponseDataBoolean: {
      trace: components["schemas"]["GetScoresResponseTraceData"];
    } & components["schemas"]["BooleanScore"];
    /** GetScoresResponseData */
    GetScoresResponseData:
      | ({
          /** @enum {string} */
          dataType: "NUMERIC";
        } & components["schemas"]["GetScoresResponseDataNumeric"])
      | ({
          /** @enum {string} */
          dataType: "CATEGORICAL";
        } & components["schemas"]["GetScoresResponseDataCategorical"])
      | ({
          /** @enum {string} */
          dataType: "BOOLEAN";
        } & components["schemas"]["GetScoresResponseDataBoolean"]);
    /** GetScoresResponse */
    GetScoresResponse: {
      data: components["schemas"]["GetScoresResponseData"][];
      meta: components["schemas"]["utilsMetaResponse"];
    };
    /** PaginatedSessions */
    PaginatedSessions: {
      data: components["schemas"]["Session"][];
      meta: components["schemas"]["utilsMetaResponse"];
    };
    /** Traces */
    Traces: {
      data: components["schemas"]["TraceWithDetails"][];
      meta: components["schemas"]["utilsMetaResponse"];
    };
    /** Sort */
    Sort: {
      id: string;
    };
    /** utilsMetaResponse */
    utilsMetaResponse: {
      /** @description current page number */
      page: number;
      /** @description number of items per page */
      limit: number;
      /** @description number of total items given the current filters/selection (if any) */
      totalItems: number;
      /** @description number of total pages given the current limit */
      totalPages: number;
    };
  };
  responses: never;
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
  comments_get: {
    parameters: {
      query?: {
        /** @description Page number, starts at 1. */
        page?: number | null;
        /** @description Limit of items per page. If you encounter api issues due to too large page sizes, try to reduce the limit */
        limit?: number | null;
        /** @description Filter comments by object type (trace, observation, session, prompt). */
        objectType?: string | null;
        /** @description Filter comments by object id. If objectType is not provided, an error will be thrown. */
        objectId?: string | null;
        /** @description Filter comments by author user id. */
        authorUserId?: string | null;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["GetCommentsResponse"];
        };
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      405: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
    };
  };
  comments_create: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateCommentRequest"];
      };
    };
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["CreateCommentResponse"];
        };
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      405: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
    };
  };
  "comments_get-by-id": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique langfuse identifier of a comment */
        commentId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Comment"];
        };
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      405: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
    };
  };
  datasetItems_list: {
    parameters: {
      query?: {
        datasetName?: string | null;
        sourceTraceId?: string | null;
        sourceObservationId?: string | null;
        /** @description page number, starts at 1 */
        page?: number | null;
        /** @description limit of items per page */
        limit?: number | null;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["PaginatedDatasetItems"];
        };
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      405: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
    };
  };
  datasetItems_create: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateDatasetItemRequest"];
      };
    };
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["DatasetItem"];
        };
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      405: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
    };
  };
  datasetItems_get: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["DatasetItem"];
        };
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      405: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
    };
  };
  datasetRunItems_create: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateDatasetRunItemRequest"];
      };
    };
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["DatasetRunItem"];
        };
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      405: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
    };
  };
  datasets_list: {
    parameters: {
      query?: {
        /** @description page number, starts at 1 */
        page?: number | null;
        /** @description limit of items per page */
        limit?: number | null;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["PaginatedDatasets"];
        };
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      405: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
    };
  };
  datasets_create: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateDatasetRequest"];
      };
    };
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Dataset"];
        };
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      405: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
    };
  };
  datasets_get: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        datasetName: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Dataset"];
        };
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      405: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
    };
  };
  datasets_getRun: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        datasetName: string;
        runName: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["DatasetRunWithItems"];
        };
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      405: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
    };
  };
  datasets_getRuns: {
    parameters: {
      query?: {
        /** @description page number, starts at 1 */
        page?: number | null;
        /** @description limit of items per page */
        limit?: number | null;
      };
      header?: never;
      path: {
        datasetName: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["PaginatedDatasetRuns"];
        };
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      405: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
    };
  };
  health_health: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["HealthResponse"];
        };
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      405: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      503: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  ingestion_batch: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description Batch of tracing events to be ingested. Discriminated by attribute `type`. */
          batch: components["schemas"]["IngestionEvent"][];
          /** @description Optional. Metadata field used by the Langfuse SDKs for debugging. */
          metadata?: unknown;
        };
      };
    };
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["IngestionResponse"];
        };
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      405: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
    };
  };
  media_get: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique langfuse identifier of a media record */
        mediaId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["GetMediaResponse"];
        };
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      405: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
    };
  };
  media_patch: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique langfuse identifier of a media record */
        mediaId: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["PatchMediaBody"];
      };
    };
    responses: {
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      405: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
    };
  };
  media_getUploadUrl: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["GetMediaUploadUrlRequest"];
      };
    };
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["GetMediaUploadUrlResponse"];
        };
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      405: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
    };
  };
  metrics_daily: {
    parameters: {
      query?: {
        /** @description page number, starts at 1 */
        page?: number | null;
        /** @description limit of items per page */
        limit?: number | null;
        /** @description Optional filter by the name of the trace */
        traceName?: string | null;
        /** @description Optional filter by the userId associated with the trace */
        userId?: string | null;
        /** @description Optional filter for metrics where traces include all of these tags */
        tags?: (string | null)[];
        /** @description Optional filter to only include traces and observations on or after a certain datetime (ISO 8601) */
        fromTimestamp?: string | null;
        /** @description Optional filter to only include traces and observations before a certain datetime (ISO 8601) */
        toTimestamp?: string | null;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["DailyMetrics"];
        };
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      405: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
    };
  };
  models_list: {
    parameters: {
      query?: {
        /** @description page number, starts at 1 */
        page?: number | null;
        /** @description limit of items per page */
        limit?: number | null;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["PaginatedModels"];
        };
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      405: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
    };
  };
  models_create: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateModelRequest"];
      };
    };
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Model"];
        };
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      405: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
    };
  };
  models_get: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Model"];
        };
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      405: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
    };
  };
  models_delete: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      405: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
    };
  };
  observations_get: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique langfuse identifier of an observation, can be an event, span or generation */
        observationId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["ObservationsView"];
        };
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      405: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
    };
  };
  observations_getMany: {
    parameters: {
      query?: {
        /** @description Page number, starts at 1. */
        page?: number | null;
        /** @description Limit of items per page. If you encounter api issues due to too large page sizes, try to reduce the limit. */
        limit?: number | null;
        name?: string | null;
        userId?: string | null;
        type?: string | null;
        traceId?: string | null;
        parentObservationId?: string | null;
        /** @description Retrieve only observations with a start_time or or after this datetime (ISO 8601). */
        fromStartTime?: string | null;
        /** @description Retrieve only observations with a start_time before this datetime (ISO 8601). */
        toStartTime?: string | null;
        /** @description Optional filter to only include observations with a certain version. */
        version?: string | null;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["ObservationsViews"];
        };
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      405: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
    };
  };
  projects_get: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Projects"];
        };
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      405: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
    };
  };
  promptVersion_update: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the prompt */
        promptName: string;
        /** @description Version of the prompt to update */
        version: number;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description New labels for the prompt version. Labels are unique across versions. The "latest" label is reserved and managed by Langfuse. */
          newLabels: string[];
        };
      };
    };
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Prompt"];
        };
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      405: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
    };
  };
  prompts_get: {
    parameters: {
      query?: {
        /** @description Version of the prompt to be retrieved. */
        version?: number | null;
        /** @description Label of the prompt to be retrieved. Defaults to "production" if no label or version is set. */
        label?: string | null;
      };
      header?: never;
      path: {
        /** @description The name of the prompt */
        promptName: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Prompt"];
        };
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      405: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
    };
  };
  prompts_list: {
    parameters: {
      query?: {
        name?: string | null;
        label?: string | null;
        tag?: string | null;
        /** @description page number, starts at 1 */
        page?: number | null;
        /** @description limit of items per page */
        limit?: number | null;
        /** @description Optional filter to only include prompt versions created/updated on or after a certain datetime (ISO 8601) */
        fromUpdatedAt?: string | null;
        /** @description Optional filter to only include prompt versions created/updated before a certain datetime (ISO 8601) */
        toUpdatedAt?: string | null;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["PromptMetaListResponse"];
        };
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      405: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
    };
  };
  prompts_create: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreatePromptRequest"];
      };
    };
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Prompt"];
        };
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      405: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
    };
  };
  scoreConfigs_get: {
    parameters: {
      query?: {
        /** @description Page number, starts at 1. */
        page?: number | null;
        /** @description Limit of items per page. If you encounter api issues due to too large page sizes, try to reduce the limit */
        limit?: number | null;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["ScoreConfigs"];
        };
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      405: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
    };
  };
  scoreConfigs_create: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateScoreConfigRequest"];
      };
    };
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["ScoreConfig"];
        };
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      405: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
    };
  };
  "scoreConfigs_get-by-id": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique langfuse identifier of a score config */
        configId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["ScoreConfig"];
        };
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      405: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
    };
  };
  score_get: {
    parameters: {
      query?: {
        /** @description Page number, starts at 1. */
        page?: number | null;
        /** @description Limit of items per page. If you encounter api issues due to too large page sizes, try to reduce the limit. */
        limit?: number | null;
        /** @description Retrieve only scores with this userId associated to the trace. */
        userId?: string | null;
        /** @description Retrieve only scores with this name. */
        name?: string | null;
        /** @description Optional filter to only include scores created on or after a certain datetime (ISO 8601) */
        fromTimestamp?: string | null;
        /** @description Optional filter to only include scores created before a certain datetime (ISO 8601) */
        toTimestamp?: string | null;
        /** @description Retrieve only scores from a specific source. */
        source?: components["schemas"]["ScoreSource"];
        /** @description Retrieve only scores with <operator> value. */
        operator?: string | null;
        /** @description Retrieve only scores with <operator> value. */
        value?: number | null;
        /** @description Comma-separated list of score IDs to limit the results to. */
        scoreIds?: string | null;
        /** @description Retrieve only scores with a specific configId. */
        configId?: string | null;
        /** @description Retrieve only scores with a specific annotation queueId. */
        queueId?: string | null;
        /** @description Retrieve only scores with a specific dataType. */
        dataType?: components["schemas"]["ScoreDataType"];
        /** @description Only scores linked to traces that include all of these tags will be returned. */
        traceTags?: (string | null)[];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["GetScoresResponse"];
        };
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      405: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
    };
  };
  score_create: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateScoreRequest"];
      };
    };
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["CreateScoreResponse"];
        };
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      405: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
    };
  };
  "score_get-by-id": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique langfuse identifier of a score */
        scoreId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Score"];
        };
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      405: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
    };
  };
  score_delete: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique langfuse identifier of a score */
        scoreId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      405: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
    };
  };
  sessions_list: {
    parameters: {
      query?: {
        /** @description Page number, starts at 1 */
        page?: number | null;
        /** @description Limit of items per page. If you encounter api issues due to too large page sizes, try to reduce the limit. */
        limit?: number | null;
        /** @description Optional filter to only include sessions created on or after a certain datetime (ISO 8601) */
        fromTimestamp?: string | null;
        /** @description Optional filter to only include sessions created before a certain datetime (ISO 8601) */
        toTimestamp?: string | null;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["PaginatedSessions"];
        };
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      405: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
    };
  };
  sessions_get: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique id of a session */
        sessionId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["SessionWithTraces"];
        };
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      405: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
    };
  };
  trace_get: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique langfuse identifier of a trace */
        traceId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["TraceWithFullDetails"];
        };
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      405: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
    };
  };
  trace_list: {
    parameters: {
      query?: {
        /** @description Page number, starts at 1 */
        page?: number | null;
        /** @description Limit of items per page. If you encounter api issues due to too large page sizes, try to reduce the limit. */
        limit?: number | null;
        userId?: string | null;
        name?: string | null;
        sessionId?: string | null;
        /** @description Optional filter to only include traces with a trace.timestamp on or after a certain datetime (ISO 8601) */
        fromTimestamp?: string | null;
        /** @description Optional filter to only include traces with a trace.timestamp before a certain datetime (ISO 8601) */
        toTimestamp?: string | null;
        /** @description Format of the string [field].[asc/desc]. Fields: id, timestamp, name, userId, release, version, public, bookmarked, sessionId. Example: timestamp.asc */
        orderBy?: string | null;
        /** @description Only traces that include all of these tags will be returned. */
        tags?: (string | null)[];
        /** @description Optional filter to only include traces with a certain version. */
        version?: string | null;
        /** @description Optional filter to only include traces with a certain release. */
        release?: string | null;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Traces"];
        };
      };
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
      405: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": unknown;
        };
      };
    };
  };
}
