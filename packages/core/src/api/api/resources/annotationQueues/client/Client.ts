/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as core from "../../../../core/index.js";
import * as LangfuseAPI from "../../../index.js";
import {
  mergeHeaders,
  mergeOnlyDefinedHeaders,
} from "../../../../core/headers.js";
import * as errors from "../../../../errors/index.js";

export declare namespace AnnotationQueues {
  export interface Options {
    environment: core.Supplier<string>;
    /** Specify a custom URL to connect the client to. */
    baseUrl?: core.Supplier<string>;
    username?: core.Supplier<string | undefined>;
    password?: core.Supplier<string | undefined>;
    /** Override the X-Langfuse-Sdk-Name header */
    xLangfuseSdkName?: core.Supplier<string | undefined>;
    /** Override the X-Langfuse-Sdk-Version header */
    xLangfuseSdkVersion?: core.Supplier<string | undefined>;
    /** Override the X-Langfuse-Public-Key header */
    xLangfusePublicKey?: core.Supplier<string | undefined>;
    /** Additional headers to include in requests. */
    headers?: Record<
      string,
      string | core.Supplier<string | null | undefined> | null | undefined
    >;
    /** Custom fetch function to use for HTTP requests */
    fetch?: typeof fetch;
  }

  export interface RequestOptions {
    /** The maximum time to wait for a response in seconds. */
    timeoutInSeconds?: number;
    /** The number of times to retry the request. Defaults to 2. */
    maxRetries?: number;
    /** A hook to abort the request. */
    abortSignal?: AbortSignal;
    /** Override the X-Langfuse-Sdk-Name header */
    xLangfuseSdkName?: string | undefined;
    /** Override the X-Langfuse-Sdk-Version header */
    xLangfuseSdkVersion?: string | undefined;
    /** Override the X-Langfuse-Public-Key header */
    xLangfusePublicKey?: string | undefined;
    /** Additional query string parameters to include in the request. */
    queryParams?: Record<string, unknown>;
    /** Additional headers to include in the request. */
    headers?: Record<
      string,
      string | core.Supplier<string | null | undefined> | null | undefined
    >;
  }
}

export class AnnotationQueues {
  protected readonly _options: AnnotationQueues.Options;

  constructor(_options: AnnotationQueues.Options) {
    this._options = _options;
  }

  /**
   * Get all annotation queues
   *
   * @param {LangfuseAPI.GetAnnotationQueuesRequest} request
   * @param {AnnotationQueues.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link LangfuseAPI.Error}
   * @throws {@link LangfuseAPI.UnauthorizedError}
   * @throws {@link LangfuseAPI.AccessDeniedError}
   * @throws {@link LangfuseAPI.MethodNotAllowedError}
   * @throws {@link LangfuseAPI.NotFoundError}
   *
   * @example
   *     await client.annotationQueues.listQueues()
   */
  public listQueues(
    request: LangfuseAPI.GetAnnotationQueuesRequest = {},
    requestOptions?: AnnotationQueues.RequestOptions,
  ): core.HttpResponsePromise<LangfuseAPI.PaginatedAnnotationQueues> {
    return core.HttpResponsePromise.fromPromise(
      this.__listQueues(request, requestOptions),
    );
  }

  private async __listQueues(
    request: LangfuseAPI.GetAnnotationQueuesRequest = {},
    requestOptions?: AnnotationQueues.RequestOptions,
  ): Promise<core.WithRawResponse<LangfuseAPI.PaginatedAnnotationQueues>> {
    const { page, limit } = request;
    const _queryParams: Record<
      string,
      string | string[] | object | object[] | null
    > = {};
    if (page != null) {
      _queryParams["page"] = page.toString();
    }

    if (limit != null) {
      _queryParams["limit"] = limit.toString();
    }

    let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
      this._options?.headers,
      mergeOnlyDefinedHeaders({
        Authorization: await this._getAuthorizationHeader(),
        "X-Langfuse-Sdk-Name":
          requestOptions?.xLangfuseSdkName ?? this._options?.xLangfuseSdkName,
        "X-Langfuse-Sdk-Version":
          requestOptions?.xLangfuseSdkVersion ??
          this._options?.xLangfuseSdkVersion,
        "X-Langfuse-Public-Key":
          requestOptions?.xLangfusePublicKey ??
          this._options?.xLangfusePublicKey,
      }),
      requestOptions?.headers,
    );
    const _response = await core.fetcher({
      url: core.url.join(
        (await core.Supplier.get(this._options.baseUrl)) ??
          (await core.Supplier.get(this._options.environment)),
        "/api/public/annotation-queues",
      ),
      method: "GET",
      headers: _headers,
      queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
      timeoutMs:
        requestOptions?.timeoutInSeconds != null
          ? requestOptions.timeoutInSeconds * 1000
          : 60000,
      maxRetries: requestOptions?.maxRetries,
      abortSignal: requestOptions?.abortSignal,
      fetch: this._options.fetch,
    });
    if (_response.ok) {
      return {
        data: _response.body as LangfuseAPI.PaginatedAnnotationQueues,
        rawResponse: _response.rawResponse,
      };
    }

    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 400:
          throw new LangfuseAPI.Error(
            _response.error.body as unknown,
            _response.rawResponse,
          );
        case 401:
          throw new LangfuseAPI.UnauthorizedError(
            _response.error.body as unknown,
            _response.rawResponse,
          );
        case 403:
          throw new LangfuseAPI.AccessDeniedError(
            _response.error.body as unknown,
            _response.rawResponse,
          );
        case 405:
          throw new LangfuseAPI.MethodNotAllowedError(
            _response.error.body as unknown,
            _response.rawResponse,
          );
        case 404:
          throw new LangfuseAPI.NotFoundError(
            _response.error.body as unknown,
            _response.rawResponse,
          );
        default:
          throw new errors.LangfuseAPIError({
            statusCode: _response.error.statusCode,
            body: _response.error.body,
            rawResponse: _response.rawResponse,
          });
      }
    }

    switch (_response.error.reason) {
      case "non-json":
        throw new errors.LangfuseAPIError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody,
          rawResponse: _response.rawResponse,
        });
      case "timeout":
        throw new errors.LangfuseAPITimeoutError(
          "Timeout exceeded when calling GET /api/public/annotation-queues.",
        );
      case "unknown":
        throw new errors.LangfuseAPIError({
          message: _response.error.errorMessage,
          rawResponse: _response.rawResponse,
        });
    }
  }

  /**
   * Create an annotation queue
   *
   * @param {LangfuseAPI.CreateAnnotationQueueRequest} request
   * @param {AnnotationQueues.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link LangfuseAPI.Error}
   * @throws {@link LangfuseAPI.UnauthorizedError}
   * @throws {@link LangfuseAPI.AccessDeniedError}
   * @throws {@link LangfuseAPI.MethodNotAllowedError}
   * @throws {@link LangfuseAPI.NotFoundError}
   *
   * @example
   *     await client.annotationQueues.createQueue({
   *         name: "name",
   *         description: undefined,
   *         scoreConfigIds: ["scoreConfigIds", "scoreConfigIds"]
   *     })
   */
  public createQueue(
    request: LangfuseAPI.CreateAnnotationQueueRequest,
    requestOptions?: AnnotationQueues.RequestOptions,
  ): core.HttpResponsePromise<LangfuseAPI.AnnotationQueue> {
    return core.HttpResponsePromise.fromPromise(
      this.__createQueue(request, requestOptions),
    );
  }

  private async __createQueue(
    request: LangfuseAPI.CreateAnnotationQueueRequest,
    requestOptions?: AnnotationQueues.RequestOptions,
  ): Promise<core.WithRawResponse<LangfuseAPI.AnnotationQueue>> {
    let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
      this._options?.headers,
      mergeOnlyDefinedHeaders({
        Authorization: await this._getAuthorizationHeader(),
        "X-Langfuse-Sdk-Name":
          requestOptions?.xLangfuseSdkName ?? this._options?.xLangfuseSdkName,
        "X-Langfuse-Sdk-Version":
          requestOptions?.xLangfuseSdkVersion ??
          this._options?.xLangfuseSdkVersion,
        "X-Langfuse-Public-Key":
          requestOptions?.xLangfusePublicKey ??
          this._options?.xLangfusePublicKey,
      }),
      requestOptions?.headers,
    );
    const _response = await core.fetcher({
      url: core.url.join(
        (await core.Supplier.get(this._options.baseUrl)) ??
          (await core.Supplier.get(this._options.environment)),
        "/api/public/annotation-queues",
      ),
      method: "POST",
      headers: _headers,
      contentType: "application/json",
      queryParameters: requestOptions?.queryParams,
      requestType: "json",
      body: request,
      timeoutMs:
        requestOptions?.timeoutInSeconds != null
          ? requestOptions.timeoutInSeconds * 1000
          : 60000,
      maxRetries: requestOptions?.maxRetries,
      abortSignal: requestOptions?.abortSignal,
      fetch: this._options.fetch,
    });
    if (_response.ok) {
      return {
        data: _response.body as LangfuseAPI.AnnotationQueue,
        rawResponse: _response.rawResponse,
      };
    }

    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 400:
          throw new LangfuseAPI.Error(
            _response.error.body as unknown,
            _response.rawResponse,
          );
        case 401:
          throw new LangfuseAPI.UnauthorizedError(
            _response.error.body as unknown,
            _response.rawResponse,
          );
        case 403:
          throw new LangfuseAPI.AccessDeniedError(
            _response.error.body as unknown,
            _response.rawResponse,
          );
        case 405:
          throw new LangfuseAPI.MethodNotAllowedError(
            _response.error.body as unknown,
            _response.rawResponse,
          );
        case 404:
          throw new LangfuseAPI.NotFoundError(
            _response.error.body as unknown,
            _response.rawResponse,
          );
        default:
          throw new errors.LangfuseAPIError({
            statusCode: _response.error.statusCode,
            body: _response.error.body,
            rawResponse: _response.rawResponse,
          });
      }
    }

    switch (_response.error.reason) {
      case "non-json":
        throw new errors.LangfuseAPIError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody,
          rawResponse: _response.rawResponse,
        });
      case "timeout":
        throw new errors.LangfuseAPITimeoutError(
          "Timeout exceeded when calling POST /api/public/annotation-queues.",
        );
      case "unknown":
        throw new errors.LangfuseAPIError({
          message: _response.error.errorMessage,
          rawResponse: _response.rawResponse,
        });
    }
  }

  /**
   * Get an annotation queue by ID
   *
   * @param {string} queueId - The unique identifier of the annotation queue
   * @param {AnnotationQueues.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link LangfuseAPI.Error}
   * @throws {@link LangfuseAPI.UnauthorizedError}
   * @throws {@link LangfuseAPI.AccessDeniedError}
   * @throws {@link LangfuseAPI.MethodNotAllowedError}
   * @throws {@link LangfuseAPI.NotFoundError}
   *
   * @example
   *     await client.annotationQueues.getQueue("queueId")
   */
  public getQueue(
    queueId: string,
    requestOptions?: AnnotationQueues.RequestOptions,
  ): core.HttpResponsePromise<LangfuseAPI.AnnotationQueue> {
    return core.HttpResponsePromise.fromPromise(
      this.__getQueue(queueId, requestOptions),
    );
  }

  private async __getQueue(
    queueId: string,
    requestOptions?: AnnotationQueues.RequestOptions,
  ): Promise<core.WithRawResponse<LangfuseAPI.AnnotationQueue>> {
    let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
      this._options?.headers,
      mergeOnlyDefinedHeaders({
        Authorization: await this._getAuthorizationHeader(),
        "X-Langfuse-Sdk-Name":
          requestOptions?.xLangfuseSdkName ?? this._options?.xLangfuseSdkName,
        "X-Langfuse-Sdk-Version":
          requestOptions?.xLangfuseSdkVersion ??
          this._options?.xLangfuseSdkVersion,
        "X-Langfuse-Public-Key":
          requestOptions?.xLangfusePublicKey ??
          this._options?.xLangfusePublicKey,
      }),
      requestOptions?.headers,
    );
    const _response = await core.fetcher({
      url: core.url.join(
        (await core.Supplier.get(this._options.baseUrl)) ??
          (await core.Supplier.get(this._options.environment)),
        `/api/public/annotation-queues/${encodeURIComponent(queueId)}`,
      ),
      method: "GET",
      headers: _headers,
      queryParameters: requestOptions?.queryParams,
      timeoutMs:
        requestOptions?.timeoutInSeconds != null
          ? requestOptions.timeoutInSeconds * 1000
          : 60000,
      maxRetries: requestOptions?.maxRetries,
      abortSignal: requestOptions?.abortSignal,
      fetch: this._options.fetch,
    });
    if (_response.ok) {
      return {
        data: _response.body as LangfuseAPI.AnnotationQueue,
        rawResponse: _response.rawResponse,
      };
    }

    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 400:
          throw new LangfuseAPI.Error(
            _response.error.body as unknown,
            _response.rawResponse,
          );
        case 401:
          throw new LangfuseAPI.UnauthorizedError(
            _response.error.body as unknown,
            _response.rawResponse,
          );
        case 403:
          throw new LangfuseAPI.AccessDeniedError(
            _response.error.body as unknown,
            _response.rawResponse,
          );
        case 405:
          throw new LangfuseAPI.MethodNotAllowedError(
            _response.error.body as unknown,
            _response.rawResponse,
          );
        case 404:
          throw new LangfuseAPI.NotFoundError(
            _response.error.body as unknown,
            _response.rawResponse,
          );
        default:
          throw new errors.LangfuseAPIError({
            statusCode: _response.error.statusCode,
            body: _response.error.body,
            rawResponse: _response.rawResponse,
          });
      }
    }

    switch (_response.error.reason) {
      case "non-json":
        throw new errors.LangfuseAPIError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody,
          rawResponse: _response.rawResponse,
        });
      case "timeout":
        throw new errors.LangfuseAPITimeoutError(
          "Timeout exceeded when calling GET /api/public/annotation-queues/{queueId}.",
        );
      case "unknown":
        throw new errors.LangfuseAPIError({
          message: _response.error.errorMessage,
          rawResponse: _response.rawResponse,
        });
    }
  }

  /**
   * Get items for a specific annotation queue
   *
   * @param {string} queueId - The unique identifier of the annotation queue
   * @param {LangfuseAPI.GetAnnotationQueueItemsRequest} request
   * @param {AnnotationQueues.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link LangfuseAPI.Error}
   * @throws {@link LangfuseAPI.UnauthorizedError}
   * @throws {@link LangfuseAPI.AccessDeniedError}
   * @throws {@link LangfuseAPI.MethodNotAllowedError}
   * @throws {@link LangfuseAPI.NotFoundError}
   *
   * @example
   *     await client.annotationQueues.listQueueItems("queueId")
   */
  public listQueueItems(
    queueId: string,
    request: LangfuseAPI.GetAnnotationQueueItemsRequest = {},
    requestOptions?: AnnotationQueues.RequestOptions,
  ): core.HttpResponsePromise<LangfuseAPI.PaginatedAnnotationQueueItems> {
    return core.HttpResponsePromise.fromPromise(
      this.__listQueueItems(queueId, request, requestOptions),
    );
  }

  private async __listQueueItems(
    queueId: string,
    request: LangfuseAPI.GetAnnotationQueueItemsRequest = {},
    requestOptions?: AnnotationQueues.RequestOptions,
  ): Promise<core.WithRawResponse<LangfuseAPI.PaginatedAnnotationQueueItems>> {
    const { status, page, limit } = request;
    const _queryParams: Record<
      string,
      string | string[] | object | object[] | null
    > = {};
    if (status != null) {
      _queryParams["status"] = status;
    }

    if (page != null) {
      _queryParams["page"] = page.toString();
    }

    if (limit != null) {
      _queryParams["limit"] = limit.toString();
    }

    let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
      this._options?.headers,
      mergeOnlyDefinedHeaders({
        Authorization: await this._getAuthorizationHeader(),
        "X-Langfuse-Sdk-Name":
          requestOptions?.xLangfuseSdkName ?? this._options?.xLangfuseSdkName,
        "X-Langfuse-Sdk-Version":
          requestOptions?.xLangfuseSdkVersion ??
          this._options?.xLangfuseSdkVersion,
        "X-Langfuse-Public-Key":
          requestOptions?.xLangfusePublicKey ??
          this._options?.xLangfusePublicKey,
      }),
      requestOptions?.headers,
    );
    const _response = await core.fetcher({
      url: core.url.join(
        (await core.Supplier.get(this._options.baseUrl)) ??
          (await core.Supplier.get(this._options.environment)),
        `/api/public/annotation-queues/${encodeURIComponent(queueId)}/items`,
      ),
      method: "GET",
      headers: _headers,
      queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
      timeoutMs:
        requestOptions?.timeoutInSeconds != null
          ? requestOptions.timeoutInSeconds * 1000
          : 60000,
      maxRetries: requestOptions?.maxRetries,
      abortSignal: requestOptions?.abortSignal,
      fetch: this._options.fetch,
    });
    if (_response.ok) {
      return {
        data: _response.body as LangfuseAPI.PaginatedAnnotationQueueItems,
        rawResponse: _response.rawResponse,
      };
    }

    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 400:
          throw new LangfuseAPI.Error(
            _response.error.body as unknown,
            _response.rawResponse,
          );
        case 401:
          throw new LangfuseAPI.UnauthorizedError(
            _response.error.body as unknown,
            _response.rawResponse,
          );
        case 403:
          throw new LangfuseAPI.AccessDeniedError(
            _response.error.body as unknown,
            _response.rawResponse,
          );
        case 405:
          throw new LangfuseAPI.MethodNotAllowedError(
            _response.error.body as unknown,
            _response.rawResponse,
          );
        case 404:
          throw new LangfuseAPI.NotFoundError(
            _response.error.body as unknown,
            _response.rawResponse,
          );
        default:
          throw new errors.LangfuseAPIError({
            statusCode: _response.error.statusCode,
            body: _response.error.body,
            rawResponse: _response.rawResponse,
          });
      }
    }

    switch (_response.error.reason) {
      case "non-json":
        throw new errors.LangfuseAPIError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody,
          rawResponse: _response.rawResponse,
        });
      case "timeout":
        throw new errors.LangfuseAPITimeoutError(
          "Timeout exceeded when calling GET /api/public/annotation-queues/{queueId}/items.",
        );
      case "unknown":
        throw new errors.LangfuseAPIError({
          message: _response.error.errorMessage,
          rawResponse: _response.rawResponse,
        });
    }
  }

  /**
   * Get a specific item from an annotation queue
   *
   * @param {string} queueId - The unique identifier of the annotation queue
   * @param {string} itemId - The unique identifier of the annotation queue item
   * @param {AnnotationQueues.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link LangfuseAPI.Error}
   * @throws {@link LangfuseAPI.UnauthorizedError}
   * @throws {@link LangfuseAPI.AccessDeniedError}
   * @throws {@link LangfuseAPI.MethodNotAllowedError}
   * @throws {@link LangfuseAPI.NotFoundError}
   *
   * @example
   *     await client.annotationQueues.getQueueItem("queueId", "itemId")
   */
  public getQueueItem(
    queueId: string,
    itemId: string,
    requestOptions?: AnnotationQueues.RequestOptions,
  ): core.HttpResponsePromise<LangfuseAPI.AnnotationQueueItem> {
    return core.HttpResponsePromise.fromPromise(
      this.__getQueueItem(queueId, itemId, requestOptions),
    );
  }

  private async __getQueueItem(
    queueId: string,
    itemId: string,
    requestOptions?: AnnotationQueues.RequestOptions,
  ): Promise<core.WithRawResponse<LangfuseAPI.AnnotationQueueItem>> {
    let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
      this._options?.headers,
      mergeOnlyDefinedHeaders({
        Authorization: await this._getAuthorizationHeader(),
        "X-Langfuse-Sdk-Name":
          requestOptions?.xLangfuseSdkName ?? this._options?.xLangfuseSdkName,
        "X-Langfuse-Sdk-Version":
          requestOptions?.xLangfuseSdkVersion ??
          this._options?.xLangfuseSdkVersion,
        "X-Langfuse-Public-Key":
          requestOptions?.xLangfusePublicKey ??
          this._options?.xLangfusePublicKey,
      }),
      requestOptions?.headers,
    );
    const _response = await core.fetcher({
      url: core.url.join(
        (await core.Supplier.get(this._options.baseUrl)) ??
          (await core.Supplier.get(this._options.environment)),
        `/api/public/annotation-queues/${encodeURIComponent(queueId)}/items/${encodeURIComponent(itemId)}`,
      ),
      method: "GET",
      headers: _headers,
      queryParameters: requestOptions?.queryParams,
      timeoutMs:
        requestOptions?.timeoutInSeconds != null
          ? requestOptions.timeoutInSeconds * 1000
          : 60000,
      maxRetries: requestOptions?.maxRetries,
      abortSignal: requestOptions?.abortSignal,
      fetch: this._options.fetch,
    });
    if (_response.ok) {
      return {
        data: _response.body as LangfuseAPI.AnnotationQueueItem,
        rawResponse: _response.rawResponse,
      };
    }

    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 400:
          throw new LangfuseAPI.Error(
            _response.error.body as unknown,
            _response.rawResponse,
          );
        case 401:
          throw new LangfuseAPI.UnauthorizedError(
            _response.error.body as unknown,
            _response.rawResponse,
          );
        case 403:
          throw new LangfuseAPI.AccessDeniedError(
            _response.error.body as unknown,
            _response.rawResponse,
          );
        case 405:
          throw new LangfuseAPI.MethodNotAllowedError(
            _response.error.body as unknown,
            _response.rawResponse,
          );
        case 404:
          throw new LangfuseAPI.NotFoundError(
            _response.error.body as unknown,
            _response.rawResponse,
          );
        default:
          throw new errors.LangfuseAPIError({
            statusCode: _response.error.statusCode,
            body: _response.error.body,
            rawResponse: _response.rawResponse,
          });
      }
    }

    switch (_response.error.reason) {
      case "non-json":
        throw new errors.LangfuseAPIError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody,
          rawResponse: _response.rawResponse,
        });
      case "timeout":
        throw new errors.LangfuseAPITimeoutError(
          "Timeout exceeded when calling GET /api/public/annotation-queues/{queueId}/items/{itemId}.",
        );
      case "unknown":
        throw new errors.LangfuseAPIError({
          message: _response.error.errorMessage,
          rawResponse: _response.rawResponse,
        });
    }
  }

  /**
   * Add an item to an annotation queue
   *
   * @param {string} queueId - The unique identifier of the annotation queue
   * @param {LangfuseAPI.CreateAnnotationQueueItemRequest} request
   * @param {AnnotationQueues.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link LangfuseAPI.Error}
   * @throws {@link LangfuseAPI.UnauthorizedError}
   * @throws {@link LangfuseAPI.AccessDeniedError}
   * @throws {@link LangfuseAPI.MethodNotAllowedError}
   * @throws {@link LangfuseAPI.NotFoundError}
   *
   * @example
   *     await client.annotationQueues.createQueueItem("queueId", {
   *         objectId: "objectId",
   *         objectType: "TRACE",
   *         status: undefined
   *     })
   */
  public createQueueItem(
    queueId: string,
    request: LangfuseAPI.CreateAnnotationQueueItemRequest,
    requestOptions?: AnnotationQueues.RequestOptions,
  ): core.HttpResponsePromise<LangfuseAPI.AnnotationQueueItem> {
    return core.HttpResponsePromise.fromPromise(
      this.__createQueueItem(queueId, request, requestOptions),
    );
  }

  private async __createQueueItem(
    queueId: string,
    request: LangfuseAPI.CreateAnnotationQueueItemRequest,
    requestOptions?: AnnotationQueues.RequestOptions,
  ): Promise<core.WithRawResponse<LangfuseAPI.AnnotationQueueItem>> {
    let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
      this._options?.headers,
      mergeOnlyDefinedHeaders({
        Authorization: await this._getAuthorizationHeader(),
        "X-Langfuse-Sdk-Name":
          requestOptions?.xLangfuseSdkName ?? this._options?.xLangfuseSdkName,
        "X-Langfuse-Sdk-Version":
          requestOptions?.xLangfuseSdkVersion ??
          this._options?.xLangfuseSdkVersion,
        "X-Langfuse-Public-Key":
          requestOptions?.xLangfusePublicKey ??
          this._options?.xLangfusePublicKey,
      }),
      requestOptions?.headers,
    );
    const _response = await core.fetcher({
      url: core.url.join(
        (await core.Supplier.get(this._options.baseUrl)) ??
          (await core.Supplier.get(this._options.environment)),
        `/api/public/annotation-queues/${encodeURIComponent(queueId)}/items`,
      ),
      method: "POST",
      headers: _headers,
      contentType: "application/json",
      queryParameters: requestOptions?.queryParams,
      requestType: "json",
      body: request,
      timeoutMs:
        requestOptions?.timeoutInSeconds != null
          ? requestOptions.timeoutInSeconds * 1000
          : 60000,
      maxRetries: requestOptions?.maxRetries,
      abortSignal: requestOptions?.abortSignal,
      fetch: this._options.fetch,
    });
    if (_response.ok) {
      return {
        data: _response.body as LangfuseAPI.AnnotationQueueItem,
        rawResponse: _response.rawResponse,
      };
    }

    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 400:
          throw new LangfuseAPI.Error(
            _response.error.body as unknown,
            _response.rawResponse,
          );
        case 401:
          throw new LangfuseAPI.UnauthorizedError(
            _response.error.body as unknown,
            _response.rawResponse,
          );
        case 403:
          throw new LangfuseAPI.AccessDeniedError(
            _response.error.body as unknown,
            _response.rawResponse,
          );
        case 405:
          throw new LangfuseAPI.MethodNotAllowedError(
            _response.error.body as unknown,
            _response.rawResponse,
          );
        case 404:
          throw new LangfuseAPI.NotFoundError(
            _response.error.body as unknown,
            _response.rawResponse,
          );
        default:
          throw new errors.LangfuseAPIError({
            statusCode: _response.error.statusCode,
            body: _response.error.body,
            rawResponse: _response.rawResponse,
          });
      }
    }

    switch (_response.error.reason) {
      case "non-json":
        throw new errors.LangfuseAPIError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody,
          rawResponse: _response.rawResponse,
        });
      case "timeout":
        throw new errors.LangfuseAPITimeoutError(
          "Timeout exceeded when calling POST /api/public/annotation-queues/{queueId}/items.",
        );
      case "unknown":
        throw new errors.LangfuseAPIError({
          message: _response.error.errorMessage,
          rawResponse: _response.rawResponse,
        });
    }
  }

  /**
   * Update an annotation queue item
   *
   * @param {string} queueId - The unique identifier of the annotation queue
   * @param {string} itemId - The unique identifier of the annotation queue item
   * @param {LangfuseAPI.UpdateAnnotationQueueItemRequest} request
   * @param {AnnotationQueues.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link LangfuseAPI.Error}
   * @throws {@link LangfuseAPI.UnauthorizedError}
   * @throws {@link LangfuseAPI.AccessDeniedError}
   * @throws {@link LangfuseAPI.MethodNotAllowedError}
   * @throws {@link LangfuseAPI.NotFoundError}
   *
   * @example
   *     await client.annotationQueues.updateQueueItem("queueId", "itemId", {
   *         status: undefined
   *     })
   */
  public updateQueueItem(
    queueId: string,
    itemId: string,
    request: LangfuseAPI.UpdateAnnotationQueueItemRequest,
    requestOptions?: AnnotationQueues.RequestOptions,
  ): core.HttpResponsePromise<LangfuseAPI.AnnotationQueueItem> {
    return core.HttpResponsePromise.fromPromise(
      this.__updateQueueItem(queueId, itemId, request, requestOptions),
    );
  }

  private async __updateQueueItem(
    queueId: string,
    itemId: string,
    request: LangfuseAPI.UpdateAnnotationQueueItemRequest,
    requestOptions?: AnnotationQueues.RequestOptions,
  ): Promise<core.WithRawResponse<LangfuseAPI.AnnotationQueueItem>> {
    let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
      this._options?.headers,
      mergeOnlyDefinedHeaders({
        Authorization: await this._getAuthorizationHeader(),
        "X-Langfuse-Sdk-Name":
          requestOptions?.xLangfuseSdkName ?? this._options?.xLangfuseSdkName,
        "X-Langfuse-Sdk-Version":
          requestOptions?.xLangfuseSdkVersion ??
          this._options?.xLangfuseSdkVersion,
        "X-Langfuse-Public-Key":
          requestOptions?.xLangfusePublicKey ??
          this._options?.xLangfusePublicKey,
      }),
      requestOptions?.headers,
    );
    const _response = await core.fetcher({
      url: core.url.join(
        (await core.Supplier.get(this._options.baseUrl)) ??
          (await core.Supplier.get(this._options.environment)),
        `/api/public/annotation-queues/${encodeURIComponent(queueId)}/items/${encodeURIComponent(itemId)}`,
      ),
      method: "PATCH",
      headers: _headers,
      contentType: "application/json",
      queryParameters: requestOptions?.queryParams,
      requestType: "json",
      body: request,
      timeoutMs:
        requestOptions?.timeoutInSeconds != null
          ? requestOptions.timeoutInSeconds * 1000
          : 60000,
      maxRetries: requestOptions?.maxRetries,
      abortSignal: requestOptions?.abortSignal,
      fetch: this._options.fetch,
    });
    if (_response.ok) {
      return {
        data: _response.body as LangfuseAPI.AnnotationQueueItem,
        rawResponse: _response.rawResponse,
      };
    }

    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 400:
          throw new LangfuseAPI.Error(
            _response.error.body as unknown,
            _response.rawResponse,
          );
        case 401:
          throw new LangfuseAPI.UnauthorizedError(
            _response.error.body as unknown,
            _response.rawResponse,
          );
        case 403:
          throw new LangfuseAPI.AccessDeniedError(
            _response.error.body as unknown,
            _response.rawResponse,
          );
        case 405:
          throw new LangfuseAPI.MethodNotAllowedError(
            _response.error.body as unknown,
            _response.rawResponse,
          );
        case 404:
          throw new LangfuseAPI.NotFoundError(
            _response.error.body as unknown,
            _response.rawResponse,
          );
        default:
          throw new errors.LangfuseAPIError({
            statusCode: _response.error.statusCode,
            body: _response.error.body,
            rawResponse: _response.rawResponse,
          });
      }
    }

    switch (_response.error.reason) {
      case "non-json":
        throw new errors.LangfuseAPIError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody,
          rawResponse: _response.rawResponse,
        });
      case "timeout":
        throw new errors.LangfuseAPITimeoutError(
          "Timeout exceeded when calling PATCH /api/public/annotation-queues/{queueId}/items/{itemId}.",
        );
      case "unknown":
        throw new errors.LangfuseAPIError({
          message: _response.error.errorMessage,
          rawResponse: _response.rawResponse,
        });
    }
  }

  /**
   * Remove an item from an annotation queue
   *
   * @param {string} queueId - The unique identifier of the annotation queue
   * @param {string} itemId - The unique identifier of the annotation queue item
   * @param {AnnotationQueues.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link LangfuseAPI.Error}
   * @throws {@link LangfuseAPI.UnauthorizedError}
   * @throws {@link LangfuseAPI.AccessDeniedError}
   * @throws {@link LangfuseAPI.MethodNotAllowedError}
   * @throws {@link LangfuseAPI.NotFoundError}
   *
   * @example
   *     await client.annotationQueues.deleteQueueItem("queueId", "itemId")
   */
  public deleteQueueItem(
    queueId: string,
    itemId: string,
    requestOptions?: AnnotationQueues.RequestOptions,
  ): core.HttpResponsePromise<LangfuseAPI.DeleteAnnotationQueueItemResponse> {
    return core.HttpResponsePromise.fromPromise(
      this.__deleteQueueItem(queueId, itemId, requestOptions),
    );
  }

  private async __deleteQueueItem(
    queueId: string,
    itemId: string,
    requestOptions?: AnnotationQueues.RequestOptions,
  ): Promise<
    core.WithRawResponse<LangfuseAPI.DeleteAnnotationQueueItemResponse>
  > {
    let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
      this._options?.headers,
      mergeOnlyDefinedHeaders({
        Authorization: await this._getAuthorizationHeader(),
        "X-Langfuse-Sdk-Name":
          requestOptions?.xLangfuseSdkName ?? this._options?.xLangfuseSdkName,
        "X-Langfuse-Sdk-Version":
          requestOptions?.xLangfuseSdkVersion ??
          this._options?.xLangfuseSdkVersion,
        "X-Langfuse-Public-Key":
          requestOptions?.xLangfusePublicKey ??
          this._options?.xLangfusePublicKey,
      }),
      requestOptions?.headers,
    );
    const _response = await core.fetcher({
      url: core.url.join(
        (await core.Supplier.get(this._options.baseUrl)) ??
          (await core.Supplier.get(this._options.environment)),
        `/api/public/annotation-queues/${encodeURIComponent(queueId)}/items/${encodeURIComponent(itemId)}`,
      ),
      method: "DELETE",
      headers: _headers,
      queryParameters: requestOptions?.queryParams,
      timeoutMs:
        requestOptions?.timeoutInSeconds != null
          ? requestOptions.timeoutInSeconds * 1000
          : 60000,
      maxRetries: requestOptions?.maxRetries,
      abortSignal: requestOptions?.abortSignal,
      fetch: this._options.fetch,
    });
    if (_response.ok) {
      return {
        data: _response.body as LangfuseAPI.DeleteAnnotationQueueItemResponse,
        rawResponse: _response.rawResponse,
      };
    }

    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 400:
          throw new LangfuseAPI.Error(
            _response.error.body as unknown,
            _response.rawResponse,
          );
        case 401:
          throw new LangfuseAPI.UnauthorizedError(
            _response.error.body as unknown,
            _response.rawResponse,
          );
        case 403:
          throw new LangfuseAPI.AccessDeniedError(
            _response.error.body as unknown,
            _response.rawResponse,
          );
        case 405:
          throw new LangfuseAPI.MethodNotAllowedError(
            _response.error.body as unknown,
            _response.rawResponse,
          );
        case 404:
          throw new LangfuseAPI.NotFoundError(
            _response.error.body as unknown,
            _response.rawResponse,
          );
        default:
          throw new errors.LangfuseAPIError({
            statusCode: _response.error.statusCode,
            body: _response.error.body,
            rawResponse: _response.rawResponse,
          });
      }
    }

    switch (_response.error.reason) {
      case "non-json":
        throw new errors.LangfuseAPIError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody,
          rawResponse: _response.rawResponse,
        });
      case "timeout":
        throw new errors.LangfuseAPITimeoutError(
          "Timeout exceeded when calling DELETE /api/public/annotation-queues/{queueId}/items/{itemId}.",
        );
      case "unknown":
        throw new errors.LangfuseAPIError({
          message: _response.error.errorMessage,
          rawResponse: _response.rawResponse,
        });
    }
  }

  /**
   * Create an assignment for a user to an annotation queue
   *
   * @param {string} queueId - The unique identifier of the annotation queue
   * @param {LangfuseAPI.AnnotationQueueAssignmentRequest} request
   * @param {AnnotationQueues.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link LangfuseAPI.Error}
   * @throws {@link LangfuseAPI.UnauthorizedError}
   * @throws {@link LangfuseAPI.AccessDeniedError}
   * @throws {@link LangfuseAPI.MethodNotAllowedError}
   * @throws {@link LangfuseAPI.NotFoundError}
   *
   * @example
   *     await client.annotationQueues.createQueueAssignment("queueId", {
   *         userId: "userId"
   *     })
   */
  public createQueueAssignment(
    queueId: string,
    request: LangfuseAPI.AnnotationQueueAssignmentRequest,
    requestOptions?: AnnotationQueues.RequestOptions,
  ): core.HttpResponsePromise<LangfuseAPI.CreateAnnotationQueueAssignmentResponse> {
    return core.HttpResponsePromise.fromPromise(
      this.__createQueueAssignment(queueId, request, requestOptions),
    );
  }

  private async __createQueueAssignment(
    queueId: string,
    request: LangfuseAPI.AnnotationQueueAssignmentRequest,
    requestOptions?: AnnotationQueues.RequestOptions,
  ): Promise<
    core.WithRawResponse<LangfuseAPI.CreateAnnotationQueueAssignmentResponse>
  > {
    let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
      this._options?.headers,
      mergeOnlyDefinedHeaders({
        Authorization: await this._getAuthorizationHeader(),
        "X-Langfuse-Sdk-Name":
          requestOptions?.xLangfuseSdkName ?? this._options?.xLangfuseSdkName,
        "X-Langfuse-Sdk-Version":
          requestOptions?.xLangfuseSdkVersion ??
          this._options?.xLangfuseSdkVersion,
        "X-Langfuse-Public-Key":
          requestOptions?.xLangfusePublicKey ??
          this._options?.xLangfusePublicKey,
      }),
      requestOptions?.headers,
    );
    const _response = await core.fetcher({
      url: core.url.join(
        (await core.Supplier.get(this._options.baseUrl)) ??
          (await core.Supplier.get(this._options.environment)),
        `/api/public/annotation-queues/${encodeURIComponent(queueId)}/assignments`,
      ),
      method: "POST",
      headers: _headers,
      contentType: "application/json",
      queryParameters: requestOptions?.queryParams,
      requestType: "json",
      body: request,
      timeoutMs:
        requestOptions?.timeoutInSeconds != null
          ? requestOptions.timeoutInSeconds * 1000
          : 60000,
      maxRetries: requestOptions?.maxRetries,
      abortSignal: requestOptions?.abortSignal,
      fetch: this._options.fetch,
    });
    if (_response.ok) {
      return {
        data: _response.body as LangfuseAPI.CreateAnnotationQueueAssignmentResponse,
        rawResponse: _response.rawResponse,
      };
    }

    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 400:
          throw new LangfuseAPI.Error(
            _response.error.body as unknown,
            _response.rawResponse,
          );
        case 401:
          throw new LangfuseAPI.UnauthorizedError(
            _response.error.body as unknown,
            _response.rawResponse,
          );
        case 403:
          throw new LangfuseAPI.AccessDeniedError(
            _response.error.body as unknown,
            _response.rawResponse,
          );
        case 405:
          throw new LangfuseAPI.MethodNotAllowedError(
            _response.error.body as unknown,
            _response.rawResponse,
          );
        case 404:
          throw new LangfuseAPI.NotFoundError(
            _response.error.body as unknown,
            _response.rawResponse,
          );
        default:
          throw new errors.LangfuseAPIError({
            statusCode: _response.error.statusCode,
            body: _response.error.body,
            rawResponse: _response.rawResponse,
          });
      }
    }

    switch (_response.error.reason) {
      case "non-json":
        throw new errors.LangfuseAPIError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody,
          rawResponse: _response.rawResponse,
        });
      case "timeout":
        throw new errors.LangfuseAPITimeoutError(
          "Timeout exceeded when calling POST /api/public/annotation-queues/{queueId}/assignments.",
        );
      case "unknown":
        throw new errors.LangfuseAPIError({
          message: _response.error.errorMessage,
          rawResponse: _response.rawResponse,
        });
    }
  }

  /**
   * Delete an assignment for a user to an annotation queue
   *
   * @param {string} queueId - The unique identifier of the annotation queue
   * @param {LangfuseAPI.AnnotationQueueAssignmentRequest} request
   * @param {AnnotationQueues.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link LangfuseAPI.Error}
   * @throws {@link LangfuseAPI.UnauthorizedError}
   * @throws {@link LangfuseAPI.AccessDeniedError}
   * @throws {@link LangfuseAPI.MethodNotAllowedError}
   * @throws {@link LangfuseAPI.NotFoundError}
   *
   * @example
   *     await client.annotationQueues.deleteQueueAssignment("queueId", {
   *         userId: "userId"
   *     })
   */
  public deleteQueueAssignment(
    queueId: string,
    request: LangfuseAPI.AnnotationQueueAssignmentRequest,
    requestOptions?: AnnotationQueues.RequestOptions,
  ): core.HttpResponsePromise<LangfuseAPI.DeleteAnnotationQueueAssignmentResponse> {
    return core.HttpResponsePromise.fromPromise(
      this.__deleteQueueAssignment(queueId, request, requestOptions),
    );
  }

  private async __deleteQueueAssignment(
    queueId: string,
    request: LangfuseAPI.AnnotationQueueAssignmentRequest,
    requestOptions?: AnnotationQueues.RequestOptions,
  ): Promise<
    core.WithRawResponse<LangfuseAPI.DeleteAnnotationQueueAssignmentResponse>
  > {
    let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
      this._options?.headers,
      mergeOnlyDefinedHeaders({
        Authorization: await this._getAuthorizationHeader(),
        "X-Langfuse-Sdk-Name":
          requestOptions?.xLangfuseSdkName ?? this._options?.xLangfuseSdkName,
        "X-Langfuse-Sdk-Version":
          requestOptions?.xLangfuseSdkVersion ??
          this._options?.xLangfuseSdkVersion,
        "X-Langfuse-Public-Key":
          requestOptions?.xLangfusePublicKey ??
          this._options?.xLangfusePublicKey,
      }),
      requestOptions?.headers,
    );
    const _response = await core.fetcher({
      url: core.url.join(
        (await core.Supplier.get(this._options.baseUrl)) ??
          (await core.Supplier.get(this._options.environment)),
        `/api/public/annotation-queues/${encodeURIComponent(queueId)}/assignments`,
      ),
      method: "DELETE",
      headers: _headers,
      contentType: "application/json",
      queryParameters: requestOptions?.queryParams,
      requestType: "json",
      body: request,
      timeoutMs:
        requestOptions?.timeoutInSeconds != null
          ? requestOptions.timeoutInSeconds * 1000
          : 60000,
      maxRetries: requestOptions?.maxRetries,
      abortSignal: requestOptions?.abortSignal,
      fetch: this._options.fetch,
    });
    if (_response.ok) {
      return {
        data: _response.body as LangfuseAPI.DeleteAnnotationQueueAssignmentResponse,
        rawResponse: _response.rawResponse,
      };
    }

    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 400:
          throw new LangfuseAPI.Error(
            _response.error.body as unknown,
            _response.rawResponse,
          );
        case 401:
          throw new LangfuseAPI.UnauthorizedError(
            _response.error.body as unknown,
            _response.rawResponse,
          );
        case 403:
          throw new LangfuseAPI.AccessDeniedError(
            _response.error.body as unknown,
            _response.rawResponse,
          );
        case 405:
          throw new LangfuseAPI.MethodNotAllowedError(
            _response.error.body as unknown,
            _response.rawResponse,
          );
        case 404:
          throw new LangfuseAPI.NotFoundError(
            _response.error.body as unknown,
            _response.rawResponse,
          );
        default:
          throw new errors.LangfuseAPIError({
            statusCode: _response.error.statusCode,
            body: _response.error.body,
            rawResponse: _response.rawResponse,
          });
      }
    }

    switch (_response.error.reason) {
      case "non-json":
        throw new errors.LangfuseAPIError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody,
          rawResponse: _response.rawResponse,
        });
      case "timeout":
        throw new errors.LangfuseAPITimeoutError(
          "Timeout exceeded when calling DELETE /api/public/annotation-queues/{queueId}/assignments.",
        );
      case "unknown":
        throw new errors.LangfuseAPIError({
          message: _response.error.errorMessage,
          rawResponse: _response.rawResponse,
        });
    }
  }

  protected async _getAuthorizationHeader(): Promise<string | undefined> {
    const username = await core.Supplier.get(this._options.username);
    const password = await core.Supplier.get(this._options.password);
    if (username != null && password != null) {
      return core.BasicAuth.toAuthorizationHeader({
        username: username,
        password: password,
      });
    }

    return undefined;
  }
}
