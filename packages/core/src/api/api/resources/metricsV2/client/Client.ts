/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as core from "../../../../core/index.js";
import * as LangfuseAPI from "../../../index.js";
import {
  mergeHeaders,
  mergeOnlyDefinedHeaders,
} from "../../../../core/headers.js";
import * as errors from "../../../../errors/index.js";

export declare namespace MetricsV2 {
  export interface Options {
    environment: core.Supplier<string>;
    /** Specify a custom URL to connect the client to. */
    baseUrl?: core.Supplier<string>;
    username?: core.Supplier<string | undefined>;
    password?: core.Supplier<string | undefined>;
    /** Override the X-Langfuse-Sdk-Name header */
    xLangfuseSdkName?: core.Supplier<string | undefined>;
    /** Override the X-Langfuse-Sdk-Version header */
    xLangfuseSdkVersion?: core.Supplier<string | undefined>;
    /** Override the X-Langfuse-Public-Key header */
    xLangfusePublicKey?: core.Supplier<string | undefined>;
    /** Additional headers to include in requests. */
    headers?: Record<
      string,
      string | core.Supplier<string | null | undefined> | null | undefined
    >;
    /** Custom fetch function to use for HTTP requests */
    fetch?: typeof fetch;
  }

  export interface RequestOptions {
    /** The maximum time to wait for a response in seconds. */
    timeoutInSeconds?: number;
    /** The number of times to retry the request. Defaults to 2. */
    maxRetries?: number;
    /** A hook to abort the request. */
    abortSignal?: AbortSignal;
    /** Override the X-Langfuse-Sdk-Name header */
    xLangfuseSdkName?: string | undefined;
    /** Override the X-Langfuse-Sdk-Version header */
    xLangfuseSdkVersion?: string | undefined;
    /** Override the X-Langfuse-Public-Key header */
    xLangfusePublicKey?: string | undefined;
    /** Additional query string parameters to include in the request. */
    queryParams?: Record<string, unknown>;
    /** Additional headers to include in the request. */
    headers?: Record<
      string,
      string | core.Supplier<string | null | undefined> | null | undefined
    >;
  }
}

export class MetricsV2 {
  protected readonly _options: MetricsV2.Options;

  constructor(_options: MetricsV2.Options) {
    this._options = _options;
  }

  /**
   * Get metrics from the Langfuse project using a query object. V2 endpoint with optimized performance.
   *
   * ## V2 Differences
   * - Supports `observations`, `scores-numeric`, and `scores-categorical` views only (traces view not supported)
   * - Direct access to tags and release fields on observations
   * - Backwards-compatible: traceName, traceRelease, traceVersion dimensions are still available on observations view
   * - High cardinality dimensions are not supported and will return a 400 error (see below)
   *
   * For more details, see the [Metrics API documentation](https://langfuse.com/docs/metrics/features/metrics-api).
   *
   * ## Available Views
   *
   * ### observations
   * Query observation-level data (spans, generations, events).
   *
   * **Dimensions:**
   * - `environment` - Deployment environment (e.g., production, staging)
   * - `type` - Type of observation (SPAN, GENERATION, EVENT)
   * - `name` - Name of the observation
   * - `level` - Logging level of the observation
   * - `version` - Version of the observation
   * - `tags` - User-defined tags
   * - `release` - Release version
   * - `traceName` - Name of the parent trace (backwards-compatible)
   * - `traceRelease` - Release version of the parent trace (backwards-compatible, maps to release)
   * - `traceVersion` - Version of the parent trace (backwards-compatible, maps to version)
   * - `providedModelName` - Name of the model used
   * - `promptName` - Name of the prompt used
   * - `promptVersion` - Version of the prompt used
   * - `startTimeMonth` - Month of start_time in YYYY-MM format
   *
   * **Measures:**
   * - `count` - Total number of observations
   * - `latency` - Observation latency (milliseconds)
   * - `streamingLatency` - Generation latency from completion start to end (milliseconds)
   * - `inputTokens` - Sum of input tokens consumed
   * - `outputTokens` - Sum of output tokens produced
   * - `totalTokens` - Sum of all tokens consumed
   * - `outputTokensPerSecond` - Output tokens per second
   * - `tokensPerSecond` - Total tokens per second
   * - `inputCost` - Input cost (USD)
   * - `outputCost` - Output cost (USD)
   * - `totalCost` - Total cost (USD)
   * - `timeToFirstToken` - Time to first token (milliseconds)
   * - `countScores` - Number of scores attached to the observation
   *
   * ### scores-numeric
   * Query numeric and boolean score data.
   *
   * **Dimensions:**
   * - `environment` - Deployment environment
   * - `name` - Name of the score (e.g., accuracy, toxicity)
   * - `source` - Origin of the score (API, ANNOTATION, EVAL)
   * - `dataType` - Data type (NUMERIC, BOOLEAN)
   * - `configId` - Identifier of the score config
   * - `timestampMonth` - Month in YYYY-MM format
   * - `timestampDay` - Day in YYYY-MM-DD format
   * - `value` - Numeric value of the score
   * - `traceName` - Name of the parent trace
   * - `tags` - Tags
   * - `traceRelease` - Release version
   * - `traceVersion` - Version
   * - `observationName` - Name of the associated observation
   * - `observationModelName` - Model name of the associated observation
   * - `observationPromptName` - Prompt name of the associated observation
   * - `observationPromptVersion` - Prompt version of the associated observation
   *
   * **Measures:**
   * - `count` - Total number of scores
   * - `value` - Score value (for aggregations)
   *
   * ### scores-categorical
   * Query categorical score data. Same dimensions as scores-numeric except uses `stringValue` instead of `value`.
   *
   * **Measures:**
   * - `count` - Total number of scores
   *
   * ## High Cardinality Dimensions
   * The following dimensions cannot be used as grouping dimensions in v2 metrics API as they can cause performance issues.
   * Use them in filters instead.
   *
   * **observations view:**
   * - `id` - Use traceId filter to narrow down results
   * - `traceId` - Use traceId filter instead
   * - `userId` - Use userId filter instead
   * - `sessionId` - Use sessionId filter instead
   * - `parentObservationId` - Use parentObservationId filter instead
   *
   * **scores-numeric / scores-categorical views:**
   * - `id` - Use specific filters to narrow down results
   * - `traceId` - Use traceId filter instead
   * - `userId` - Use userId filter instead
   * - `sessionId` - Use sessionId filter instead
   * - `observationId` - Use observationId filter instead
   *
   * ## Aggregations
   * Available aggregation functions: `sum`, `avg`, `count`, `max`, `min`, `p50`, `p75`, `p90`, `p95`, `p99`, `histogram`
   *
   * ## Time Granularities
   * Available granularities for timeDimension: `auto`, `minute`, `hour`, `day`, `week`, `month`
   * - `auto` bins the data into approximately 50 buckets based on the time range
   *
   * @param {LangfuseAPI.GetMetricsV2Request} request
   * @param {MetricsV2.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link LangfuseAPI.Error}
   * @throws {@link LangfuseAPI.UnauthorizedError}
   * @throws {@link LangfuseAPI.AccessDeniedError}
   * @throws {@link LangfuseAPI.MethodNotAllowedError}
   * @throws {@link LangfuseAPI.NotFoundError}
   *
   * @example
   *     await client.metricsV2.metrics({
   *         query: "query"
   *     })
   */
  public metrics(
    request: LangfuseAPI.GetMetricsV2Request,
    requestOptions?: MetricsV2.RequestOptions,
  ): core.HttpResponsePromise<LangfuseAPI.MetricsV2Response> {
    return core.HttpResponsePromise.fromPromise(
      this.__metrics(request, requestOptions),
    );
  }

  private async __metrics(
    request: LangfuseAPI.GetMetricsV2Request,
    requestOptions?: MetricsV2.RequestOptions,
  ): Promise<core.WithRawResponse<LangfuseAPI.MetricsV2Response>> {
    const { query } = request;
    const _queryParams: Record<
      string,
      string | string[] | object | object[] | null
    > = {};
    _queryParams["query"] = query;
    let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
      this._options?.headers,
      mergeOnlyDefinedHeaders({
        Authorization: await this._getAuthorizationHeader(),
        "X-Langfuse-Sdk-Name":
          requestOptions?.xLangfuseSdkName ?? this._options?.xLangfuseSdkName,
        "X-Langfuse-Sdk-Version":
          requestOptions?.xLangfuseSdkVersion ??
          this._options?.xLangfuseSdkVersion,
        "X-Langfuse-Public-Key":
          requestOptions?.xLangfusePublicKey ??
          this._options?.xLangfusePublicKey,
      }),
      requestOptions?.headers,
    );
    const _response = await core.fetcher({
      url: core.url.join(
        (await core.Supplier.get(this._options.baseUrl)) ??
          (await core.Supplier.get(this._options.environment)),
        "/api/public/v2/metrics",
      ),
      method: "GET",
      headers: _headers,
      queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
      timeoutMs:
        requestOptions?.timeoutInSeconds != null
          ? requestOptions.timeoutInSeconds * 1000
          : 60000,
      maxRetries: requestOptions?.maxRetries,
      abortSignal: requestOptions?.abortSignal,
      fetch: this._options.fetch,
    });
    if (_response.ok) {
      return {
        data: _response.body as LangfuseAPI.MetricsV2Response,
        rawResponse: _response.rawResponse,
      };
    }

    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 400:
          throw new LangfuseAPI.Error(
            _response.error.body as unknown,
            _response.rawResponse,
          );
        case 401:
          throw new LangfuseAPI.UnauthorizedError(
            _response.error.body as unknown,
            _response.rawResponse,
          );
        case 403:
          throw new LangfuseAPI.AccessDeniedError(
            _response.error.body as unknown,
            _response.rawResponse,
          );
        case 405:
          throw new LangfuseAPI.MethodNotAllowedError(
            _response.error.body as unknown,
            _response.rawResponse,
          );
        case 404:
          throw new LangfuseAPI.NotFoundError(
            _response.error.body as unknown,
            _response.rawResponse,
          );
        default:
          throw new errors.LangfuseAPIError({
            statusCode: _response.error.statusCode,
            body: _response.error.body,
            rawResponse: _response.rawResponse,
          });
      }
    }

    switch (_response.error.reason) {
      case "non-json":
        throw new errors.LangfuseAPIError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody,
          rawResponse: _response.rawResponse,
        });
      case "timeout":
        throw new errors.LangfuseAPITimeoutError(
          "Timeout exceeded when calling GET /api/public/v2/metrics.",
        );
      case "unknown":
        throw new errors.LangfuseAPIError({
          message: _response.error.errorMessage,
          rawResponse: _response.rawResponse,
        });
    }
  }

  protected async _getAuthorizationHeader(): Promise<string | undefined> {
    const username = await core.Supplier.get(this._options.username);
    const password = await core.Supplier.get(this._options.password);
    if (username != null && password != null) {
      return core.BasicAuth.toAuthorizationHeader({
        username: username,
        password: password,
      });
    }

    return undefined;
  }
}
